<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-0.9.345">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jonny Law">
<meta name="dcterms.date" content="2020-05-01">

<title>blog-quarto - Functional Programming and Hidden Markov Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link id="quarto-text-highlighting-styles" href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">blog-quarto</span>
  </a>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"><i class="bi bi-twitter" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Functional Programming and Hidden Markov Models</h1>
                          <div class="quarto-categories">
                <div class="quarto-category">BayesianR</div>
              </div>
                  </div>
  </div>
    
  



  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jonny Law </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 1, 2020</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>The hidden Markov model is a state-space model with a discrete latent state, <span class="math inline">\(x_{1:T}\)</span> and noisy observations <span class="math inline">\(y_{1:T}\)</span>. The model can be described mathematically as</p>
<p><span class="math display">\[p(y_{1:T}, x_{1:T}) = p(x_1)p(y_1|x_1)\prod_{t=2}^Tp(y_t|x_t)p(x_t|x_{t-1})\]</span></p>
<p>Where <span class="math inline">\(y_{1:T} = y_1, \dots, y_T\)</span> represents the sequence of observed values and <span class="math inline">\(x_{1:T} = x_1, \dots, x_T\)</span> is the sequence of latent, unobserved values. The state space is assumed to be finite and countable, <span class="math inline">\(X \in \{1,\dots,K\}\)</span> and the time gaps between each observation are constant. The observation distribution can be either continuous or discrete.</p>
<p>The model can be visualised using a state-transition diagram where observed nodes are rectangular and latent nodes are circular. The arrows represent any transitions which can be made and also convey conditional independence assumptions in the Model. The state forms a first order Markov process, which means <span class="math inline">\(p(x_t|x_{t-1},\dots,x_1) = p(x_t|x_{t-1})\)</span> and each observation is conditionally independent of all others given the corresponding value of the latent state at that time, <span class="math inline">\(y_t \perp\!\!\!\perp y_{1:t-1},y_{t+1:T}\)</span></p>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/hmm-1.png" class="img-fluid" style="width:90.0%"></p>
</div>
</div>
<!-- ![state transition diagram for hmm](/blog/hidden-markov-model_files/hmm.png) -->
<section id="example-the-occasionally-dishonest-casino" class="level2">
<h2 class="anchored" data-anchor-id="example-the-occasionally-dishonest-casino">Example: The occasionally dishonest casino</h2>
<p>The casino can choose to use a fair dice, in which case the observation distribution is categorical with probabilities <span class="math inline">\(p = \{\frac{1}{6}, \frac{1}{6}, \frac{1}{6}, \frac{1}{6}, \frac{1}{6}, \frac{1}{6}\}\)</span>. The casino can also choose a loaded dice which has the following probabilities, <span class="math inline">\(p = \{\frac{1}{10}, \frac{1}{10}, \frac{1}{10}, \frac{1}{10}, \frac{1}{10}, \frac{1}{5}\}\)</span>, hence it is more likely to roll a six with the loaded dice.</p>
<p>We want to infer when the casino is using the loaded dice, the latent state <span class="math inline">\(x \in \{L, F\}\)</span> for loaded and fair respectively. We assume we already know the transition matrix</p>
$$P =
<span class="math display">\[\begin{pmatrix}


\alpha &amp; 1 - \alpha \\
1 - \beta &amp; \beta
\end{pmatrix}\]</span>
<p>.$$</p>
<div class="cell">

</div>
<p>The observation distribution is <span class="math inline">\(p(y_t|x_t = j)\)</span>. This implies we have a two element vector since the state can take one of two values <span class="math inline">\(j = \{L, F\}\)</span>.</p>
<div class="cell">

</div>
<div class="cell">

</div>
<p>We can simulate data from this process by specifying values of the parameters, <span class="math inline">\(\alpha = 0.3\)</span> and <span class="math inline">\(\beta = 0.1\)</span>. This means if the casino is using the loaded dice we will transition to the fair dice with probability <span class="math inline">\(1 - \alpha\)</span> and if the casino is using the fair dice there is a <span class="math inline">\(1 - \beta\)</span> probability of transitioning to the loaded dice. The algorithm to simulate from this Hidden Markov model is</p>
<ol type="1">
<li>Specify the initial state of the dice, <span class="math inline">\(x_1 = L\)</span></li>
<li>Simulate an initial observation conditional on the dice used, <span class="math inline">\(y_1 \sim p(y_1|x_1)\)</span></li>
<li>Simulate the next transition by drawing from a categorical distribution with probabilities corresponding to the row of the transition matrix corresponding the current state, <span class="math inline">\(P_{x_t, \cdot}\)</span></li>
<li>Simulate an observation conditional on the state, <span class="math inline">\(y_t \sim p(y_t|x_t)\)</span></li>
<li>Repeat 3 - 4 until the desired number of realisations are simulated</li>
</ol>
<div class="cell">

</div>
<p>The plot below shows 300 simulations from the occasionally dishonest casino.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="filtering" class="level2">
<h2 class="anchored" data-anchor-id="filtering">Filtering</h2>
<p>Now we wish to identify when the casino is using the loaded dice. We can use the forward filtering algorithm. The first step of the forward algorithm is to the prediction step:</p>
<p><span class="math display">\[p(x_t = k|y_{1:t-1}) = \sum_{j=1}^K p(x_t = k|x_{t-1}=j)p(x_{t-1}=k|y_{1:t-1})\]</span></p>
<p>Then we observe a new value of the process <span class="math inline">\(y_t\)</span>, and perform the update step where we apply Bayes’ Theorem</p>
$$
<span class="math display">\[\begin{aligned}


p(x_t = k \mid y_{1:t}) = p(x_t = k\mid y_t,y_{1:t-1}) &amp;= \frac{p(y_{t}|x_t = k, y_{1:t-1})p(x_t = k|y_{1:t-1})}{p(y_{t})} \\
&amp;= \frac{p(y_{t}|x_t = k)p(x_t = k|y_{1:t-1})}{\sum_{j=1}^Kp(y_{t}|x_t = j)p(x_t = j|y_{1:t-1})}
\end{aligned}\]</span>
<p>$$</p>
<p>Which can be calculated recursively by defining <span class="math inline">\(\alpha_t(k) = p(x_t = k \mid y_{1:t})\)</span> then we have the recursive update</p>
<p><span class="math display">\[\begin{aligned}
\alpha_t(k) &amp;= p(y_{t}|x_t = k)p(x_t = k|y_{1:t-1}) \\
&amp;= p(y_{t}|x_t = k)\sum_{j=1}^Kp(x_t = k|x_{t-1} = j)p(x_{t-1}\mid y_{1:t-1})\\
&amp;= p(y_{t}|x_t = k)\sum_{j=1}^Kp(x_t = k|x_{t-1} = j)\alpha_{t-1}(k)
\end{aligned}\]</span></p>
<p>Essentially we have use the posterior of the previous time point, <span class="math inline">\(\alpha_{t-1}(k)\)</span> as the prior for next observation. Then we advance the latent-state using the transition distribution <span class="math inline">\(p(x_t = k|x_{t-1} = j)\)</span> and calculate the likelihood of the observation at time <span class="math inline">\(t\)</span> using the observation distribution <span class="math inline">\(p(y_{t}|x_t = k)\)</span>.</p>
<p>To implement the forward algorithm in <code>R</code> we can use a higher-order function, a <a href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">fold</a>, from the <code>R</code> package <a href="https://purrr.tidyverse.org/">purrr</a>. A higher-order function is a function which accepts a function as an argument or returns a function instead of a value such as a <code>double</code> or <code>int</code>. This might seem strange at first, but it is very useful and quite common in statistics. Consider maximising a function using an optimisation routine, we pass in a function and the initial arguments and the optimisation function and the function is evaluated at many different values until a plausible maximum is found. This is the basis of the <code>optim</code> function in R.</p>
<p>Higher-order functions can be motivated by considering a foundational principle of functional programming, to write pure functions which do not mutate state. A pure function is one which returns the same output value for the same function arguments. This means we can’t mutate state by sampling random numbers, write to disk or a database etc. Advanced functional programming languages, such as Haskell, encapsulates this behaviour in Monads. However, Monads and other higher-kinded types are not present in <code>R</code>. While we can’t use all the useful elements of functional programming in <code>R</code>, we can use some, such as higher-order functions.</p>
<p>One result of avoiding mutable state is that we can’t write a for-loop, since a for-loop has a counter which is mutated at each iteration (<code>i = i + 1</code>). To overcome this apparent obstacle we can use recursion. Consider the simple example of adding together all elements in a vector, if we are naive we can write a for-loop.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>seq <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>total <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(seq)) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  total <span class="ot">=</span> total <span class="sc">+</span> seq[i]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>total</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 55</code></pre>
</div>
</div>
<p>This implementation has two variables which are mutated to calculate the final results. To avoid mutating state, we can write a recursive function which calls itself.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>loop <span class="ot">&lt;-</span> <span class="cf">function</span>(total, seq) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(seq) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    total</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">loop</span>(total <span class="sc">+</span> seq[<span class="dv">1</span>], seq[<span class="sc">-</span><span class="dv">1</span>])</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="fu">loop</span>(<span class="dv">0</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 55</code></pre>
</div>
</div>
<p><code>R</code> does not have <a href="https://en.wikipedia.org/wiki/Tail_call">tail-call elimination</a> and hence this recursive function will not work with long sequences, however it does not mutate any state. We can generalise this function to be a higher-order function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>fold <span class="ot">&lt;-</span> <span class="cf">function</span>(init, seq, f) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(seq) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    init</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fold</span>(<span class="fu">f</span>(init, seq[<span class="dv">1</span>]), seq[<span class="sc">-</span><span class="dv">1</span>], f)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here the function <code>fold</code> applies the user-specified binary function <code>f</code> to the initial value <code>init</code> and the first element of the sequence. The result of applying <code>f</code> to these values is then used as the next initial value with the rest of the sequence. We can use this to calculate any binary reduction we can think of.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fold</span>(<span class="dv">1</span>, seq, <span class="cf">function</span>(x, y) x <span class="sc">*</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3628800</code></pre>
</div>
</div>
<p>This example is equivalent to the <code>reduce</code> function in <a href="https://purrr.tidyverse.org/">purrr</a>. <code>purrr::reduce</code> by default can be used to combine the elements of a vector or list using a binary function starting with the first element in the list. For instance we can calculate the sum of a vector of numbers</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">reduce</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="cf">function</span>(x, y) x <span class="sc">+</span> y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 55</code></pre>
</div>
</div>
<p>We can also use the function shorthand provided in <code>purrr</code>, where <code>function(x, y) x + y</code> can be written <code>~ .x + .y</code>.</p>
<p>Other arguments provided to the <code>reduce</code> function can change its behaviour such as reversing the direction by changing the <code>.direction</code> argument (which will not affect the above computation, since addition is associative, ie. <span class="math inline">\((1 + (2 + 3)) = ((1 + 2) + 3)\)</span>). We can also provide an initial value (<code>.init</code>) to the computation, instead of starting with the first (or last) element of the list.</p>
<p><code>purrr::accumulate</code> is similar to reduce, however it does not discard intermediate computations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">accumulate</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="st">`</span><span class="at">+</span><span class="st">`</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  1  3  6 10 15 21 28 36 45 55</code></pre>
</div>
</div>
<p>Hence, if we change the direction this will change the output.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>purrr<span class="sc">::</span><span class="fu">accumulate</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="st">`</span><span class="at">+</span><span class="st">`</span>, <span class="at">.dir =</span> <span class="st">"backward"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 55 54 52 49 45 40 34 27 19 10</code></pre>
</div>
</div>
<p>These functions can appear strange at first, however they don’t suffer from common problems such as off-by-one errors when writing a for-loop with indexing.</p>
<p>The <code>accumulate</code> function can be used to write the forward algorithm by first writing a single step in the forward algorithm. The function <code>forward_step</code> accepts the current smoothed state at time t-1, <code>alpha</code>, and the observed value at time t, <code>y</code>. The arguments <code>observation</code> and <code>P</code> represent the observation distribution and the transition matrix respectively and remain constant in this example</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>forward_step <span class="ot">&lt;-</span> <span class="cf">function</span>(alpha, y, observation, P) {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">normalise</span>(<span class="fu">observation</span>(y) <span class="sc">*</span> <span class="fu">t</span>(P) <span class="sc">%*%</span> alpha)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The forward algorithm can then be written using the <code>accumulate</code> function by first calculating the initial value of <code>alpha</code> and using this as the value <code>.init</code> then the function <code>forward_step</code> is used with the values of <code>observation</code> and <code>P</code> set. <code>accumulate</code> then takes uses the initial value, <code>.init</code> and the first value of the observations, <code>ys</code> (technically the second since we use the first to initialise <code>alpha</code>) to produce the next <code>alpha</code> value. This new <code>alpha</code> value is passed to the next invocation of <code>forward_step</code> along with the next observed value and so on until the observation vector is exhausted.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>forward <span class="ot">&lt;-</span> <span class="cf">function</span>(ys, x0, observation, P) {</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="fu">normalise</span>(<span class="fu">observation</span>(ys[<span class="dv">1</span>]) <span class="sc">*</span> x0)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  purrr<span class="sc">::</span><span class="fu">accumulate</span>(</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    ys[<span class="sc">-</span><span class="dv">1</span>],</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    forward_step,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">observation =</span> observation,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">P =</span> P,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">.init =</span> alpha</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We assume that the dice used for the initial roll can be either loaded or fair with equal probability.</p>
<div class="cell">

</div>
<div class="cell">

</div>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="parameter-inference" class="level2">
<h2 class="anchored" data-anchor-id="parameter-inference">Parameter inference</h2>
<p>We can calculate the log-probability of the evidence using the forward algorithm, this is the sum of un-normalised filtering distribution</p>
<p><span class="math display">\[\log p(y_{1:T}) = \log \sum_{i=1}^T\sum_{j=1}^K p(x_t=j\mid y_{1:t-1})p(y_t|x_t = j)\]</span></p>
<p>This can be used in a Metropolis-Hastings algorithm to determine the posterior distribution of the parameters in the transition matrix, <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span>. We can keep a running total of log-likelihood by returning a list from the forward step containing the log-likelihood and the posterior probability of the states given the observation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>ll_step <span class="ot">&lt;-</span> <span class="cf">function</span>(state, y, observation, P) {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  unnorm_state <span class="ot">&lt;-</span> <span class="fu">observation</span>(y) <span class="sc">*</span> <span class="fu">t</span>(P) <span class="sc">%*%</span> state[[<span class="dv">2</span>]]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    state[[<span class="dv">1</span>]] <span class="sc">+</span> <span class="fu">sum</span>(<span class="fu">log</span>(unnorm_state)),</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">normalise</span>(unnorm_state)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To return only the log-likelihood we can use <code>purrr::reduce</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>log_likelihood <span class="ot">&lt;-</span> <span class="cf">function</span>(ys, x0, observation, P) {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  alpha <span class="ot">&lt;-</span> <span class="fu">normalise</span>(<span class="fu">observation</span>(ys[<span class="dv">1</span>]) <span class="sc">*</span> x0)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  init <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="dv">0</span>, alpha)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  purrr<span class="sc">::</span><span class="fu">reduce</span>(ys, <span class="cf">function</span>(x, y) <span class="fu">ll_step</span>(x, y, observation, P), <span class="at">.init =</span> init)[[<span class="dv">1</span>]]</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can use this marginal-likelihood in a Metropolis-Hastings algorithm. We define the prior on the parameters of the transition matrix to be independent Gamma distributions with shape, <span class="math inline">\(\alpha = 3\)</span>, and rate <span class="math inline">\(\beta = 3/0.1\)</span>. The log-posterior is the sum of the log-likelihood calculated using the forward filtering algorithm and the log-prior.</p>
<div class="cell">

</div>
<p>The proposal distribution is a normal centered at the un-constrained value of the parameter. We use the logit function to transform <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> from <span class="math inline">\(\operatorname{logit}:[0, 1] \rightarrow \mathbb{R}\)</span> then propose using a Normal distribution centered as the un-constrained value and proceed to transform the parameter back to the original scale using the logistic function, <span class="math inline">\(\operatorname{logistic}:\mathbb{R} \rightarrow [0, 1]\)</span>.</p>
<div class="cell">

</div>
<div class="cell" data-hash="index_cache/html/hmm-mcmc_1c52b243dc6a6bb2d3968328d7954b02">

</div>
<p>We draw 10,000 iterations from the Metropolis algorithm, the parameter diagnostics are plotted below.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid" width="672"></p>
</div>
</div>


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{law2020,
  author = {Jonny Law and Jonny Law},
  title = {Functional {Programming} and {Hidden} {Markov} {Models}},
  date = {2020-05-01},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-law2020" class="csl-entry quarto-appendix-citeas" role="doc-biblioentry">
Jonny Law, and Jonny Law. 2020. <span>“Functional Programming and Hidden
Markov Models.”</span> May 1, 2020.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>