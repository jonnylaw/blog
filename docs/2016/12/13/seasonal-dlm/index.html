<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.30.2" />


<title>Seasonal DLM - Probabilistic Programming in Scala</title>
<meta property="og:title" content="Seasonal DLM - Probabilistic Programming in Scala">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/tomorrow-night-eighties.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/blog/css/fonts.css" media="all">
<link rel="stylesheet" href="/blog/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/blog/" class="nav-logo">
    <img src="/blog/images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/blog/about/">About</a></li>
    
    <li><a href="/blog/">Blog</a></li>
    
    <li><a href="https://github.com/jonnylaw">GitHub</a></li>
    
    <li><a href="https://twitter.com/lawsy">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">4 min read</span>
    

    <h1 class="article-title">Seasonal DLM</h1>

    
    <span class="article-date">2016/12/13</span>
    

    <div class="article-content">
      <div id="the-seasonal-dlm" class="section level2">
<h2>The Seasonal DLM</h2>
<p>I introduced the class of state space models called DLMs in a previous post covering the <a href="KalmanFilter/">Kalman Filter</a>. The seasonal DLM is similar to the first order DLM, however it incorporates a deterministic transformation to the state, in order to capture cyclic trends. Remember a general DLM can be written as:</p>
<p><span class="math display">\[\begin{align}
y_t &amp;= F_t x_t + \nu_t, \qquad \mathcal{N}(0, V_t), \\
x_t &amp;= G_t x_{t-1} + \omega_t, \quad \mathcal{N}(0, W_t).
\end{align}\]</span></p>
<p>In the fourier-form seasonal DLM, the state is transformed by a block diagonal matrix, <span class="math inline">\(G_t\)</span>, containing rotation matrices. The rotation matrix is given by:</p>
<p><span class="math display">\[R = \begin{pmatrix}
\cos(\omega) &amp; -\sin(\omega) \\
\sin(\omega) &amp; \cos(\omega)
\end{pmatrix},\]</span> where <span class="math inline">\(\omega\)</span> is the frequency of the seasonality. In practice, it is easier to specify the period of the seasonality, <span class="math inline">\(T\)</span>, which is related to the frequency: <span class="math inline">\(\omega = 2 \pi/T\)</span>. This means if we have data measured at hourly intervals and we believe the process has a daily cycle, then we will set <span class="math inline">\(T = 24\)</span>.</p>
<p>In order to model higher harmonics of the seasonality, we combine rotation matrices together into a block diagonal matrix, to form the <span class="math inline">\(G\)</span> matrix, for instance with 3 harmonics the system matrix is:</p>
<p><span class="math display">\[G = \begin{pmatrix}
\cos(\omega) &amp; -\sin(\omega) &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
\sin(\omega) &amp; \cos(\omega) &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \cos(2\omega) &amp; -\sin(2\omega) &amp; 0&amp; 0 \\
0 &amp; 0 &amp; \sin(2\omega) &amp; \cos(2\omega) &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cos(3\omega) &amp; -\sin(3\omega) \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \sin(3\omega) &amp; \cos(3\omega) \\
\end{pmatrix}.\]</span></p>
<p>In this case, the latent state, <span class="math inline">\(x_t\)</span> is six-dimensional. This means system evolution variance-covariance matrix, <span class="math inline">\(W_t\)</span> is a six by six matrix.</p>
<p>First we should make a trait in Scala representing a DLM, this allows us to specify methods on the <code>dlm</code> object, independent of the concrete reasisation of the DLM. This means in the future we can create new DLMs, and not have to write functions to simulate from them again. The trait will be for a DLM with constant <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> matrices.</p>
<pre class="scala"><code>import breeze.linalg._

trait Dlm {
  val f: DenseMatrix[Double]
  val g: DenseMatrix[Double]
}</code></pre>
<p>Note that, for univariate observations <span class="math inline">\(F\)</span> will be a row vector, the recommended way to specify row vectors using <a href="https://github.com/scalanlp/breeze/">Breeze</a> is to use a matrix with a single row. The DLM also has associated parameters which we will assume are constant and model as a <code>case class</code>, a <code>case class</code> in Scala is a class with a default <code>apply</code> method used to construct instances of the class. The <code>case class</code> also has getter methods which can be used to access the values of the class.</p>
<pre class="scala"><code>case class Parameters(v: Double, w: DenseMatrix[Double], m0: DenseVector[Double], c0: DenseMatrix[Double])</code></pre>
<p>Then we can add a method to the <code>Dlm</code> trait to simulate forward given a value of the <code>Parameters</code>, firstly we will write a single step of the simulation:</p>
<pre class="scala"><code>case class Data(time: Double, observation: Double, state: DenseVector[Double])

def simStep(p: Parameters): Data =&gt; Rand[Data] = d =&gt; {
    for {
      w &lt;- MultivariateGaussian(DenseVector.zeros(p.w.cols), p.w)
      x1 = g * d.state + w
      v &lt;- Gaussian(0, p.v)
      y = f.toDenseVector dot x1 + v
    } yield Data(d.time + 1.0, y, x1)
  }</code></pre>
<p>This function contains a for comprehension, the <code>&lt;-</code> symbol represents either a <code>map</code> or a <code>flatMap</code>. Since the <code>w</code> and <code>v</code> are <code>Rand[Double]</code> values, we need to access the value inside of the <code>Rand</code> and perform a function on it, the for comprehension desugars to:</p>
<pre class="scala"><code>MultivariateGaussian(DenseVector.zeros(p.w.cols), p.w).
  flatMap(w =&gt; {
    val x1 = g * d.state + w
    Gaussian(0, p.v).map(v =&gt; {
      val y = f.toDenseVector dot x1 + v
      Data(d.time + 1.0, y, x1)
    })}
    )</code></pre>
<p>The desugared chain of <code>flatMap</code> and <code>map</code> evaluates to the same result, but the for comprehesion is more readable. The for comprehension provides a clean and elegent way to work within the context of a Monad, <code>Rand</code> is an example of a Monad representing a distribution.</p>
<p>Now, we can use the <code>MarkovChain</code> breeze object to simulate the full series:</p>
<pre class="scala"><code>def simMarkov(p: Parameters): Rand[Process[Data]] = {
  for {
    x0 &lt;- MultivariateGaussian(p.m0, p.c0)
    y0 &lt;- Gaussian(f.toDenseVector dot x0, p.v)
    init = Data(0.0, y0, x0)
  } yield MarkovChain(init)(simStep(p))
}</code></pre>
<p>Note that the Markov chain is a <code>Rand[Process[Double]]</code>, this is not the most elegant and Iâ€™m open to suggestions on a better way to formulate this. Once we have defined a Markov chain, we must draw from it which returns a <code>Process[Double]</code>, the initial draw is to sample from the initial state distribution <span class="math inline">\(\mathcal{N}(m_0, C_0)\)</span>. Next, we can sample from the <code>Process</code> and plot it. A simulation from the seasonal DLM, with parameters <span class="math inline">\(V = 3\)</span> and <span class="math inline">\(W = I_6\)</span>, is given below:</p>
<p><img src="/blog/post/SeasonalDlm_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/blog/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/blog/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/scala.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/blog/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

