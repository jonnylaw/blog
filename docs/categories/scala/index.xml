<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scala on Bayesian Statistics and Functional Programming </title>
    <link>/categories/scala/</link>
    <description>Recent content in scala on Bayesian Statistics and Functional Programming </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/scala/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Multi-armed Bandits in Scala</title>
      <link>/2019/04/16/multi-armed-bandits/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/04/16/multi-armed-bandits/</guid>
      <description>Setting up the Environment This post uses Almond in order to run Scala code in a Jupyter notebook. See my previous post to learn how to setup Jupyter, Ammonite and Almond. That post examined using the Scala libraries EvilPlot (including inline plotting in the Jupyter notebook) and Rainier for Bayesian inference in a simple linear model.
The imports required for this post are:
import coursier.MavenRepository interp.repositories() ++= Seq(MavenRepository( &amp;quot;http://dl.bintray.com/cibotech/public&amp;quot; )) import $ivy.</description>
    </item>
    
    <item>
      <title>Scala and Jupyter Notebook with Almond</title>
      <link>/2019/04/15/scala-and-jupyter-notebook-with-almond/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/04/15/scala-and-jupyter-notebook-with-almond/</guid>
      <description>Typically, when programming with Scala I use a combination of ensime in emacs, sbt and the Scala repl. However, sometimes when working on a new project which requires a lot of data exploration and graphics it is sometimes more useful to have a notebook where figures are rendered inline with descriptions of why each figure has been generated and what it shows for future reference. Jupyter notebooks have long been the standard in Python (although I prefer rmarkdown and knitr when using R).</description>
    </item>
    
    <item>
      <title>Using Monads for Handling Failures and Exceptions</title>
      <link>/2017/01/04/using-monads-for-handling-failures-and-exceptions/</link>
      <pubDate>Wed, 04 Jan 2017 12:13:14 -0500</pubDate>
      
      <guid>/2017/01/04/using-monads-for-handling-failures-and-exceptions/</guid>
      <description>In this post I will give a practical introduction to some useful structures for handling failure in functional programming.
Referential Transparency One of the most important properties of functional programming is referential transparency and programming with pure functions. This means we can substitute a pure function with its result, for intance if we have the function def f = 1 + 2, we can replace every occurence of f with 3 and the final evaluation will remain unchanged</description>
    </item>
    
    <item>
      <title>The Kalman Filter in Scala</title>
      <link>/2016/12/12/the-kalman-filter-in-scala/</link>
      <pubDate>Mon, 12 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/2016/12/12/the-kalman-filter-in-scala/</guid>
      <description>A Dynamic Linear Model (DLM) is a special type of state space model, where the state and observation equations are Normally distributed and linear. A general DLM can be written as follows:
\[\begin{aligned} y_t &amp;amp;= F_t x_t + \nu_t, \qquad \nu_t \sim \mathcal{N}(0, V_t) \\ x_t &amp;amp;= G_tx_{t-1} + \omega_t \qquad \omega_t \sim \mathcal{N}(0, W_t), \end{aligned}\]
\(y_t\) represents the observation of the process at time \(t\), \(x_t\) is the value of the unobserved state at time \(t\).</description>
    </item>
    
    <item>
      <title>Practical Introduction to Akka Streaming</title>
      <link>/2016/12/01/practical-introduction-to-akka-streaming/</link>
      <pubDate>Thu, 01 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/2016/12/01/practical-introduction-to-akka-streaming/</guid>
      <description>Akka Streaming is a streaming IO engine used to build high performance, fault tolerant and scalable streaming data services. In this post I will describe how you can implement some of the features included in Akka Streaming using only simple streams of integers and strings, although the true power of Akka streams only becomes apparent when we are consuming data from real sources such as Websockets, databases and files. Akka is available in Java and Scala, but I will be focusing on the Scala API in this post.</description>
    </item>
    
  </channel>
</rss>