<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.55.1" />


<title>Analysing .fit files in R - Bayesian Statistics and Functional Programming </title>
<meta property="og:title" content="Analysing .fit files in R - Bayesian Statistics and Functional Programming ">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/tomorrow-night-eighties.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/picture_cropped.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="/">Blog</a></li>
    
    <li><a href="https://github.com/jonnylaw">GitHub</a></li>
    
    <li><a href="https://twitter.com/lawsy">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">6 min read</span>
    

    <h1 class="article-title">Analysing .fit files in R</h1>

    
    <span class="article-date">2019/11/04</span>
    

    <div class="article-content">
      


<p>Garmin running watches output a file type called .fit, the developer SDK can be downloaded from the <a href="https://www.thisisant.com/developer/fit-sdk-release-notes">ANT website</a>. There is aalso Python library named <a href="https://github.com/dtcooper/python-fitparse">fitparse</a> which has been written to parse .fit files. This blog post will show you how to use <a href="https://rstudio.github.io/reticulate/">reticulate</a> to parse a .fit file.</p>
<div id="parsing" class="section level2">
<h2>Parsing</h2>
<pre class="r"><code>reticulate::py_install(&quot;fitparse&quot;, method = &quot;auto&quot;, conda = &quot;auto&quot;)</code></pre>
<pre><code>## Using virtual environment &#39;~/.virtualenvs/r-reticulate&#39; ...</code></pre>
<p>The library can be imported as an R object.</p>
<pre class="r"><code>fitparse &lt;- reticulate::import(&quot;fitparse&quot;)</code></pre>
<p>Then methods and classes defined in the fitparse Python libary can be accessed using the <code>$</code> notation. Typing <code>$</code> after fitparse (and hitting the <code>TAB</code> key) in the RStudio IDE gives a list of top-level methods and classes defined in the fitparse library.</p>
<pre class="r"><code>ff &lt;- fitparse$FitFile(fit_file)</code></pre>
<p>We can use the <code>get_messages</code> method on the <code>FitFile</code>. This returns a generator, this is a special type of lazy list in Python.</p>
<pre class="r"><code>generator &lt;- ff$get_messages(&quot;record&quot;)</code></pre>
<p><code>iterate</code> is a function provided by the <code>reticulate</code> library which can be used to traverse a Python generator:</p>
<pre class="r"><code>activity &lt;- reticulate::iterate(ff$get_messages(&quot;record&quot;), function(x) x$get_values())</code></pre>
<p>This evaluates the generator and applies the function <code>get_values</code> to retrieve the details associated with this activity. A list object is returned by R, the first element looks like this:</p>
<pre class="r"><code>activity[[1]]</code></pre>
<pre><code>## $timestamp
## 2017-03-16 17:22:08
## 
## $position_lat
## [1] 655852851
## 
## $position_long
## [1] -19374352
## 
## $distance
## [1] 3.47
## 
## $enhanced_altitude
## [1] 88.8
## 
## $altitude
## [1] 2944
## 
## $enhanced_speed
## [1] 3.471
## 
## $speed
## [1] 3471
## 
## $vertical_oscillation
## [1] 120
## 
## $stance_time_percent
## [1] 34.25
## 
## $stance_time
## [1] 259
## 
## $heart_rate
## [1] 137
## 
## $cadence
## [1] 79
## 
## $activity_type
## [1] &quot;running&quot;
## 
## $fractional_cadence
## [1] 0</code></pre>
<p>We want to transform this list of lists into a dataframe. The most straightforward way is to extract the elements of interest using the <code>map</code> function from <a href="https://purrr.tidyverse.org/">purrr</a>:</p>
<pre class="r"><code>(activity_tibble &lt;- activity %&gt;%
  map_dfr(function(x) tibble(
    timestamp = readr::parse_datetime(as.character(x$timestamp)),
    latitude = x$position_lat,
    longitude = x$position_long,
    elevation = x$enhanced_altitude,
    heart_rate = x$heart_rate,
    cadence = x$cadence
    )))</code></pre>
<pre><code>## # A tibble: 611 x 6
##    timestamp            latitude longitude elevation heart_rate cadence
##    &lt;dttm&gt;                  &lt;int&gt;     &lt;int&gt;     &lt;dbl&gt;      &lt;int&gt;   &lt;int&gt;
##  1 2017-03-16 17:22:08 655852851 -19374352      88.8        137      79
##  2 2017-03-16 17:22:09 655853310 -19375987      90.2        138      79
##  3 2017-03-16 17:22:10 655854123 -19374810      81.2        138      80
##  4 2017-03-16 17:22:15 655856545 -19372657      39.2        139      78
##  5 2017-03-16 17:22:21 655859405 -19368861      54.2        140      79
##  6 2017-03-16 17:22:26 655860948 -19365257      54.6        140      80
##  7 2017-03-16 17:22:32 655860904 -19362723      65.4        138      79
##  8 2017-03-16 17:22:33 655861059 -19361314      69          138      79
##  9 2017-03-16 17:22:37 655860087 -19358357      98.8        135      79
## 10 2017-03-16 17:22:44 655860947 -19354267      97          135      80
## # … with 601 more rows</code></pre>
<p>Notice that the latitude and longitude don’t look correct, it turns out they are in semicircles and can be converted to a recognisable coordinate system using the following function.</p>
<pre class="r"><code>semicircle_to_degrees &lt;- function(semicircle)
  semicircle * (180 / 2**31)</code></pre>
<p>Applying the function to the latitude and longitude models.</p>
<pre class="r"><code>activity_tibble &lt;- activity_tibble %&gt;% 
  mutate_at(vars(latitude, longitude), semicircle_to_degrees)</code></pre>
<p>This is a very basic summary of the activity. We can derive the distance per timestep using the longitude, latitude and timestamp fields.</p>
<pre class="r"><code>(activity_tibble &lt;- activity_tibble %&gt;%
  mutate(
    time_diff_to_prev = as.numeric(difftime(timestamp, lag(timestamp, default = .$timestamp[1]))),
    cumtime = cumsum(time_diff_to_prev),
    dist_to_prev = c(0, sp::spDists(
      x = as.matrix(.[, c(&quot;longitude&quot;, &quot;latitude&quot;)]),
      longlat = TRUE,
      segments = TRUE
    )),
    elevation_to_prev = elevation - lag(elevation),
    distance = cumsum(dist_to_prev)
    )) </code></pre>
<pre><code>## # A tibble: 611 x 11
##    timestamp           latitude longitude elevation heart_rate cadence
##    &lt;dttm&gt;                 &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;int&gt;   &lt;int&gt;
##  1 2017-03-16 17:22:08     55.0     -1.62      88.8        137      79
##  2 2017-03-16 17:22:09     55.0     -1.62      90.2        138      79
##  3 2017-03-16 17:22:10     55.0     -1.62      81.2        138      80
##  4 2017-03-16 17:22:15     55.0     -1.62      39.2        139      78
##  5 2017-03-16 17:22:21     55.0     -1.62      54.2        140      79
##  6 2017-03-16 17:22:26     55.0     -1.62      54.6        140      80
##  7 2017-03-16 17:22:32     55.0     -1.62      65.4        138      79
##  8 2017-03-16 17:22:33     55.0     -1.62      69          138      79
##  9 2017-03-16 17:22:37     55.0     -1.62      98.8        135      79
## 10 2017-03-16 17:22:44     55.0     -1.62      97          135      80
## # … with 601 more rows, and 5 more variables: time_diff_to_prev &lt;dbl&gt;,
## #   cumtime &lt;dbl&gt;, dist_to_prev &lt;dbl&gt;, elevation_to_prev &lt;dbl&gt;,
## #   distance &lt;dbl&gt;</code></pre>
</div>
<div id="summarising" class="section level2">
<h2>Summarising</h2>
<p>We can calculate a high level summary of the activity similar to what you would find on Garmin connect.</p>
<table>
<thead>
<tr class="header">
<th align="right">total_distance</th>
<th align="left">elapsed_time</th>
<th align="right">moving_time</th>
<th align="right">elevation_gain</th>
<th align="right">average_heart_rate</th>
<th align="left">average_pace</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">8.044634</td>
<td align="left">39.65 mins</td>
<td align="right">39M 39S</td>
<td align="right">380</td>
<td align="right">150</td>
<td align="left">00:04:55.72509</td>
</tr>
</tbody>
</table>
<p>We can recreate plots commonly found on activity websites such as training peaks, Strava and Garmin Connect, for instance average speed for each 1km:</p>
<p><img src="/post/parsing-strava_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p><img src="/post/parsing-strava_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
</div>
<div id="analysing-heart-rate-data" class="section level2">
<h2>Analysing heart rate data</h2>
<p>We can determine how hard the activity was for the athlete using heart rate data. Heart rate is an individual metric and differs between athletes running the same pace. To that end, we must compute the heart rate relative to the maximum heart rate or using <a href="https://fellrnr.com/wiki/Heart_Rate_Reserve">heart rate reserve</a> (taking into account both the maximum and resting heart rate). Using the max heart rate and resting heart rate, training zones can be determined. These zones are broad and for the convenience of the athlete (and coach) when performing workouts at a given intensity. This intensity should vary depending on the purpose of the workout (recovery, threshold, VO2 max intervals etc.).</p>
<p>Suggested heart rate zones according to <a href="https://www.amazon.co.uk/Advanced-Marathoning-Pete-Pfitzinger/dp/149256866X">Pete Pfitzinger</a> are:</p>
<ol style="list-style-type: decimal">
<li>Active recovery: less than 76% MHR</li>
<li>General Aerobic: 70%-81% MHR</li>
<li>Tempo (Marathon pace): 81%-88% MHR</li>
<li>Lactate Threshold: 82%-92% MHR</li>
<li>Anaerobic: 95%+</li>
</ol>
<p>For my maximum heart rate of 189, the zones can be written as.</p>
<table>
<thead>
<tr class="header">
<th align="left">zone</th>
<th align="right">heart_rate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">one</td>
<td align="right">144</td>
</tr>
<tr class="even">
<td align="left">two</td>
<td align="right">153</td>
</tr>
<tr class="odd">
<td align="left">three</td>
<td align="right">166</td>
</tr>
<tr class="even">
<td align="left">four</td>
<td align="right">174</td>
</tr>
<tr class="odd">
<td align="left">five</td>
<td align="right">189</td>
</tr>
</tbody>
</table>
<p>Then the time in zones can be plotted for the given activity.</p>
<p><img src="/post/parsing-strava_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
</div>
<div id="training-impulse" class="section level2">
<h2>Training impulse</h2>
<p>TRIMP can be used (TRaining IMPulse) to calculate a one-number summary of the activity difficulty, more information on TRIMP can be found <a href="https://fellrnr.com/wiki/TRIMP">here</a>.</p>
<p>The most straightforward way to calculate TRIMP is calculating the total time in each zone by multiplying the zone number by the total minutes in the corresponding zone.</p>
<table>
<thead>
<tr class="header">
<th align="right">trimp_zone</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">87.86667</td>
</tr>
</tbody>
</table>
<p>This number is straightforward to calculate however it lacks nuance. For instance it remains the same if the athlete is at either the upper or lower end of the heart rate range for a given zone. To account for this TRIMP exp can be calculated:</p>
<p><span class="math display">\[\textrm{TRIMP}^{\textrm{exp}} = \sum_{i=1}^T \textrm{D}_i \cdot \textrm{HRr} \cdot 0.64e^y\]</span></p>
<p>Where, <span class="math inline">\(\textrm{D}_i\)</span> is the duration of a single measurement (typically one to five seconds on a Garmin watch), HRr is the heart rate reserve (maximum heart rate - resting heart rate), <span class="math inline">\(y\)</span> is the percentage of heart rate reserve multiplied by 1.92 for men and 1.67 for women.</p>
<pre class="r"><code>trimp_exp &lt;- function(heartrate, time_seconds, max_hr, resting_hr, sex = &quot;Male&quot;) {
  heart_rate_reserve &lt;- max_hr - resting_hr
  hrr &lt;- heartrate / heart_rate_reserve
  constant &lt;- if_else(sex == &quot;Male&quot;, 1.92, 1.67)
  sum((time_seconds / 60) * hrr * 0.64 * exp(constant * hrr))
}</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">trimp_exp</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">187.6727</td>
</tr>
</tbody>
</table>
<p>These summaries can be used to calculate the overall training workload for an athlete to assist with planning and reviewing training plans. This is typically used in addition to training time and distance covered.</p>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/scala.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

