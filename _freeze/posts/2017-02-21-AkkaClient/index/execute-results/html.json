{
  "hash": "591271cdec1988344caad826225a1c9b",
  "result": {
    "markdown": "---\ntitle: \"An Akka HTTP Client with JSON Parsing\"\nauthor: \"Jonny Law\"\ndate: \"2017-02-21\"\nslug: \"akkaclient\"\ncategories: \n  - Scala\n---\n\n\n\n\n\nThere are many sources of open data on the web, freely accessible via an Application Programming Interface (API) made available over the web. A common interchange format for these APIs is Javascript Object Notation (JSON) which is human readable and predictable, however is not in the correct format for analysis. The data needs to be parsed from the JSON string and made available as an object we can work with. This blog post considers a simple [Akka Http](http://akka.io/) client to read data from the [Urban Observatory](http://uoweb1.ncl.ac.uk/) in Newcastle. If you just want to read the code, see this [Gist](https://gist.github.com/jonnylaw/028083cf3bf41923b5dc38ade58d2622).\n\n## Exploring the API\n\nThe Urban Observatory consists of a grid of sensors around the North East, measuring traffic, pollution and weather. The focus of this post will be getting sensor data from a single sensor, N05171T, a traffic sensor located near the Metro Centre on Hollinside road. The metadata from this sensor can be found by querying an API endpoint: http://uoweb1.ncl.ac.uk/api/v1/sensor.json?api_key=&sensor_name=N05171T. Note that this requires authentication, using an API key. An API key can be requested using [this form](http://uoweb1.ncl.ac.uk/api_page/key_form/). \n\nThe result of this query is:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"type\": \"Traffic\",\n    \"geom\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n            [\n                -1.674433347,\n                54.959041883\n            ],\n            [\n                -1.673947928,\n                54.959553799\n            ]\n        ]\n    },\n    \"active\": \"True\",\n    \"latest\": \"2017-02-21T08:23:06\",\n    \"base_height\": null,\n    \"sensor_height\": null,\n    \"name\": \"N05171T\",\n    \"source\": {\n        \"web_display_name\": \"NE Travel Data API (Third Party)\",\n        \"third_party\": true,\n        \"db_name\": \"Scoot Netravel Api\",\n        \"document\": \"\",\n        \"fancy_name\": \"NE Travel Data API\"\n    }\n}\n \n```\n:::\n:::\n\nWe can see a bit of information about the sensor, including its location, time of latest reading and whether the sensor is active.\n\nIn order to retrieve the actual data from the sensor, we query the url [http://uoweb1.ncl.ac.uk/api/v1/sensor/data/raw.json](http://uoweb1.ncl.ac.uk/api/v1/sensor/data/raw.json) with the following required fields:\n\n* `api_key` your API key here\n* `sensor_name` N05171T\n* `start_time` 20170201\n* `end_time` 20170202\n\nThis returns the following:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"type\": \"Traffic\",\n    \"geom\": {\n        \"type\": \"LineString\",\n        \"coordinates\": [\n            [\n                -1.674433347,\n                54.959041883\n            ],\n            [\n                -1.673947928,\n                54.959553799\n            ]\n        ]\n    },\n    \"active\": \"True\",\n    \"data\": {\n        \"Congestion\": {\n            \"data\": {\n                \"2017-02-01 01:36:46\": 0.0\n            },\n            \"meta\": {\n                \"name\": \"Congestion\",\n                \"theme\": \"Traffic\",\n                \"units\": \"%\"\n            }\n        },\n        \"Traffic Flow\": {\n            \"data\": {\n                \"2017-02-01 01:36:46\": 4.0\n            },\n            \"meta\": {\n                \"name\": \"Traffic Flow\",\n                \"theme\": \"Traffic\",\n                \"units\": \"Passenger Car Units\"\n            }\n        },\n        \"Average Speed\": {\n            \"data\": {\n                \"2017-02-01 13:21:46\": 35.0\n            },\n            \"meta\": {\n                \"name\": \"Average Speed\",\n                \"theme\": \"Traffic\",\n                \"units\": \"KmPH\"\n            }\n        }\n    },\n    \"latest\": \"2017-02-21T08:33:06\",\n    \"base_height\": null,\n    \"sensor_height\": null,\n    \"name\": \"N05171T\",\n    \"source\": {\n        \"web_display_name\": \"NE Travel Data API (Third Party)\",\n        \"third_party\": true,\n        \"db_name\": \"Scoot Netravel Api\",\n        \"document\": \"\",\n        \"fancy_name\": \"NE Travel Data API\"\n    }\n}\n \n```\n:::\n:::\n\n\nAll but one of the readings have been stripped for each `data` object to emphasize the structure of the JSON returned by the API. We can see that sensor N05171T records traffic flow, congestion, and average speed. We can provide a further (optional) field to the Urban Observatory API to limit the results to return only one these. Let's consider the only the average speed, measures in kmph. This is an unusual unit for the UK, as road speed is measured in miles per hour. \n\n## Parsing the JSON in Scala\n\nThere are many JSON parsing libraries in Scala, including my favourite [Circe](https://circe.github.io/circe/) which is a Typelevel project, providing generic parsers for case classes without additional boilerplate. However, Spray JSON and Akka HTTP work well together, so that is what we will be using today. In order to complete this tutorial, you will need the Akka HTTP and Spray JSON dependencies in your `build.sbt` file. \n\n```scala\nlibraryDependencies ++=  Seq(\n  \"com.typesafe.akka\" %% \"akka-stream\" % \"2.4.17\",\n  \"com.typesafe.akka\" %% \"akka-http\" % \"10.0.3\",\n  \"com.typesafe.akka\" %% \"akka-http-spray-json\" % \"10.0.0\")\n```\n\nFirstly, we describe the data we are interested in, in a collection of case classes representing the JSON data:\n\n```scala\ncase class Sensor(name: String, data: SensorData)\ncase class SensorData(averageSpeed: AverageSpeed)\ncase class AverageSpeed(meta: Meta, data: Map[String, Double])\ncase class Meta(units: String, theme: String, name: String)\n```\n\nWe extract the sensor name, and associated data, without bothering with the additional top-level fields. The sensor data field contains only average speed, by appending `&variable=average speed` to the end of the HTTP Get request. \n\nNow we have a domain model for the sensor data, we must provide a way for Spray JSON to parse the JSON to the case classes:\n\n```scala\nimport spray.json._\nimport akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\n\ntrait Protocols extends SprayJsonSupport with DefaultJsonProtocol {\n  implicit val metaFormat: RootJsonFormat[Meta] = \n    jsonFormat(Meta.apply, \"units\", \"theme\", \"name\")\n   implicit val averagespeedFormat: RootJsonFormat[AverageSpeed] = \n    jsonFormat(AverageSpeed.apply, \"meta\", \"data\")\n   implicit val sensorDataFormat: RootJsonFormat[SensorData] = \n    jsonFormat(SensorData.apply, \"Average Speed\")\n  implicit val sensorFormat: RootJsonFormat[Sensor] = \n    jsonFormat(Sensor.apply, \"name\", \"data\")\n}\n```\n\nThis trait can be [mixed in](http://docs.scala-lang.org/tutorials/tour/mixin-class-composition.html) when the time comes to parse the JSON data. Let's first test the JSON parsing by directly reading in the JSON we get when running the request in a web browser:\n\n```scala\nobject TestJson extends App with Protocols {\n  val json_string = scala.io.Source.fromFile(\"data/traffic_sensor.json\").getLines.mkString\n\n  json_string.\n    parseJson.\n    convertTo[List[Sensor]].\n    foreach(println)\n}\n```\n\nThere's a bit going on here, first we have a file which contains the JSON String, this could have been pasted in directly to Scala. Then the string is parsed, this is possible since the `TestJson` object has the JSON `Protocols` trait we defined earlier mixed in using `with`. \n\n## Making an API Request using Akka HTTP\n\nIn order to make an API request using Akka HTTP, we utilise the high-level client API based on Scala futures:\n\n```scala\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\nimport akka.http.scaladsl.model._\nimport akka.http.scaladsl.Http\nimport HttpMethods._\nimport akka.stream.ActorMaterializer\nimport Uri.Query\nimport scala.concurrent.Future\n\nimplicit val system = ActorSystem()\nimplicit val materializer = ActorMaterializer()\nimplicit val executionContext = system.dispatcher\n\nval uri = Uri(\"http://uoweb1.ncl.ac.uk/api/v1/sensor/data/raw.json\")\nval api_key = // your api key here\n\n  val query: Query = Query(\"api_key\" -> api_key,\n    \"sensor_name\" -> \"N05171T\",\n    \"start_time\" -> \"20170201\",\n    \"end_time\" -> \"20170202\",\n    \"variable\" -> \"average speed\")\n\nval res: Future[HttpResponse] = \n  Http().singleRequest(HttpRequest(GET, uri = uri.withQuery(query)))\n```\n\nWe have created a Query object, which is just a sequence of `(String, Sting)`, denoted using the nicer arrow syntax. The request is initialised simply as a `singleRequest` which retuns a `Future` containing the `HttpResponse`. The `HttpResponse` object contains the status (200 OK, 404 Not Found etc.), and importantly the body content, called `HttpEntity`, the `HttpEntity` in this case is simply the JSON. In order to verify we are able to make a requst to the Urban Observatory, we can match on the result of the future using `andThen`:\n\n```scala\nres andThen {\n    case Success(response) => println(response)\n    case Failure(ex) => println(ex)\n  } onComplete {\n    _ => system.terminate()\n  }\n```\n\n`andThen` expects a function from a `Try`, an algebraic data type (ADT) which can be either `Success` or `Failure`. When the future completes, we shutdown the Actor System required by Akka HTTP. When you run this minimal example, you should receive a response similar to:\n\n```\nHttpResponse(200 OK,List(Date: Tue, 21 Feb 2017 09:27:24 GMT, Server: Apache/2.4.7 (Ubuntu), Vary\n: Cookie, X-Frame-Options: SAMEORIGIN),HttpEntity.Chunked(application/json),HttpProtocol(HTTP/1.1\n))\n```\n\nThe server has returned 200 OK, some headers and some response data. In order to access the response data, we must convert it to a string, first we access the `entity` field of the `HttpResponse`, the get the results as a `ByteString` which can finally be parsed to a String:\n\n```scala\nval resp = response.\n  entity.\n  dataBytes.\n  map(_.utf8String)\n```\n\nThis is an Akka Stream, containing the response from the server. In order to parse it into the sensor data, we map over the string using the JSON parsing function we have previously seen:\n\n```scala\nresp.\n  map(_.parseJson.convertTo[List[Sensor]]).\n  runForeach(println)\n```\n\nThis should print the parsed data to the console. There are a variety of other Akka `Sink`s which can be used to consume the `HttpEntity`, they can be found in the Akka docs [overview of built in stages](http://doc.akka.io/docs/akka/current/scala/stream/stages-overview.html).\n\nA complete working example is available in this [Gist](https://gist.github.com/jonnylaw/028083cf3bf41923b5dc38ade58d2622).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}