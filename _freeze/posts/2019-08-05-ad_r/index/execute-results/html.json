{
  "hash": "8a44bd8b18cd29140478593310391ed3",
  "result": {
    "markdown": "---\ntitle: \"Forward Mode AD in R\"\nauthor: \"Jonny Law\"\ndate: \"2019-08-05\"\nslug: forward-mode-automatic-differentiation-R\ncategories: \n  - R\n---\n\n\n\n\n## Forward Mode Automatic Differentation\n\nAutomatic differentiation can be used to calculate the exact derivative of a function at a point using applications of the chain rule. Dual numbers provide a straightforward implementation in R using S3 generic methods. A dual number has a real component and a \"dual\" component which can be used to exactly calculate the expression and derivative at a specific value of $x$. Consider the quadratic form $f(x) = 5x^2 + 3x + 10$ with derivative $f^\\prime(x) = 10x + 3$. The function and derivative can be evaluated at a value, say $x = 5$ using the dual number $5 + \\varepsilon$, the dual component $\\varepsilon$ is considered small such that $\\varepsilon^2 = 0$ then calculating $f(5 + \\varepsilon)$:\n\n\n$$\\begin{align}\nf(5 + \\varepsilon) &= 5(5 + \\varepsilon)^2 + 3(5 + \\varepsilon) + 10,\\\\\n&= 5(25 + 10\\varepsilon + \\varepsilon^2) + 15 + 3\\varepsilon + 10,\\\\\n&= 5\\varepsilon^2 + 53\\varepsilon + 150.\n\\end{align}$$\n\nThen the coefficient of $\\varepsilon$ is the derivative and the constant is the evaluation of the function, $f(5) = 150$ and $f^\\prime(5) = 53$.\n\n## S3 Objects\n\nR has three systems for object oriented programming, S3, S4 and reference classes which can be learned about in the relevant chapter of [Advanced R](http://adv-r.had.co.nz/OO-essentials.html). Dual numbers can be implemented as an S3 class in R:\n\n::: {.cell}\n\n```{.r .cell-code}\ndual <- function(real, eps) {\n  if (!is.numeric(real)) stop(\"real must be numeric\")\n  structure(list(real = real, eps = eps), class = \"dual\")\n} \nvar <- function(x) {\n  if (!is.numeric(x)) stop(\"x must be numeric\")\n  dual(x, 1)\n}\nconst <- function(x) {\n  if (!is.numeric(x)) stop(\"x must be numeric\")\n  dual(x, 0)\n}\n```\n:::\n\n`var` represents a variable which we want to differentiate, whereas `const` represents a constant. \n\nNext, primitive functions can be defined in terms of `dual` numbers which simultaneously evaluate the function and the derivative:\n\n::: {.cell}\n\n```{.r .cell-code}\nplus <- function(x, y) \n  dual(x$real + y$real, x$eps + y$eps)\nminus <- function(x, y) \n  dual(x$real - y$real, x$eps - y$eps)\ntimes <- function(x, y) \n  dual(x$real * y$real, x$eps * y$real + y$eps * x$real)\ndivide <- function(x, y) \n  dual(\n      x$real / y$real,\n      (x$eps * y$real - x$real * y$eps) / (y$real * y$real)\n    )\n```\n:::\n\n\nGroup generics can be used to implement the mathematics of dual numbers. Group generics included with base R include `Math` which includes special functions such such as `abs` and `sqrt` as well as trigonometric and hyperbolic functions. `Ops` which include the basic infix operations reqruired for arithmetic, `+`, `-`, `*`, `/` etc. For a full list of group generics associated with `Math` and `Ops` consult the R help by typing `?groupGeneric` in the R console. In order to implement a group generic for the S3 class `dual` we implement `Ops.dual`:\n\n::: {.cell}\n\n```{.r .cell-code}\nOps.dual <- function(x, y) {\n  switch(\n    .Generic,\n    `+` = plus(x, y),\n    `-` = minus(x, y),\n    `*` = times(x, y),\n    `/` = divide(x, y)\n  )\n}\n```\n:::\n\n`switch` is used to pattern match on the generic function being called within `Ops` by matching on `.Generic`. Implementing dual numbers in this way allows us to define a function using the in-built infix operators in a natural way. The function $f(x)$ can be defined in terms of dual numbers as\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) \n  const(5) * x * x + const(3) * x + const(10)\n```\n:::\n\nThen evaluated at $x = 5$ using the constructor `var` which initialises a dual with $\\varepsilon = 1.0$.\n\n::: {.cell}\n\n```{.r .cell-code}\nf(var(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$real\n[1] 150\n\n$eps\n[1] 53\n\nattr(,\"class\")\n[1] \"dual\"\n```\n:::\n:::\n\nThe definition of `f` is cumbersome since we have to explicitly create the constants using the `const` constructor. The methods defined in `Ops.dual` can be extended to handle cases when a double is multiplied by a dual number to convert the double to a `const` and hence we can automatically differentiate any univariate function using forward mode automatic differentiation.\n\nWe can write a function which checks the arguments of `plus`, `minus` etc, then if the arguments aren't explicitly dual number variables using the function `var` then they are converted to a dual constant using `const`. This function checks each argument (of a generic function of two arguments `f`) in turn to determine if they are doubles then promotes them to constants.\n\n::: {.cell}\n\n```{.r .cell-code}\nlift_function <- function(f) {\n  function(x, y)\n    if (is.double(x)) {\n      f(const(x), y)\n    } else if (is.double(y)) {\n      f(x, const(y))\n    } else {\n      f(x, y)\n    }\n}\n```\n:::\n\nThe ops can then be re-defined using the `lift_function`:\n\n::: {.cell}\n\n```{.r .cell-code}\nOps.dual <- function(x, y) {\n  switch(\n    .Generic,\n    `+` = lift_function(plus)(x, y),\n    `-` = lift_function(minus)(x, y),\n    `*` = lift_function(times)(x, y),\n    `/` = lift_function(divide)(x, y)\n  )\n}\n```\n:::\n\nThen `f` can be defined more naturally:\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) \n  5 * x * x + 3 * x + 10\n```\n:::\n\nAnd the derivative calculated:\n\n::: {.cell}\n\n```{.r .cell-code}\nf(var(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$real\n[1] 150\n\n$eps\n[1] 53\n\nattr(,\"class\")\n[1] \"dual\"\n```\n:::\n:::\n\n## Testing using Hedgehog\n\n[Hedgehog](https://github.com/hedgehogqa/r-hedgehog) is a package which utilises [testthat](https://testthat.r-lib.org) to implement property based testing in R. Property based testing can be used to check a wide range of inputs to a function and determine if the code outputs the expected value. In standard unit testing the state before the test is defined by programmer and typically does not change - if we were to consider a test for the derivative of the quadratic function defined above then we might write a test which evaluates the function at $x = 5$. This verifies we are correct for $x = 5$, but what about $x = 0$ or another value. With property based testing, we define a random generator for the input and the test checks hundreds of potential values for failure.\n\nThe input to this property based test is `a`, a number between $-100$ and $100$. The usual `testthat` syntax is then used to evaluate the gradient using forward mode AD and comparing it to the exact derivative calculated by hand. \n\n::: {.cell}\n\n```{.r .cell-code}\ntest_that(\"Derivative of 5x^2 + 3x + 10\",\n          forall(list(a = gen.c(gen.element(\n            -100:100\n          ))),\n          function(a)\n            expect_equal(object = f(var(a))$eps, expected = 10 * a + 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest passed ðŸŽŠ\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}