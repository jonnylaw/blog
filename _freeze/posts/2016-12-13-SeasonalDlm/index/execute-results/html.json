{
  "hash": "b54154a6e458728a3264aa1b18ad7b94",
  "result": {
    "markdown": "---\ntitle: Seasonal DLM\nauthor: Jonny Law\ndate: \"2016-12-13\"\ncategories:\n  - [Bayesian, Scala]\n---\n\n\n\n\n## The Seasonal DLM\n\nI introduced the class of state space models called DLMs in a previous post covering the [Kalman Filter](KalmanFilter/). The seasonal DLM is similar to the first order DLM, however it incorporates a deterministic transformation to the state, in order to capture cyclic trends. Remember a general DLM can be written as:\n\n\n$$\\begin{align}\ny_t &= F_t x_t + \\nu_t, \\qquad \\mathcal{N}(0, V_t), \\\\\nx_t &= G_t x_{t-1} + \\omega_t, \\quad \\mathcal{N}(0, W_t).\n\\end{align}$$\n\nIn the fourier-form seasonal DLM, the state is transformed by a block diagonal matrix, $G_t$, containing rotation matrices. The rotation matrix is given by:\n\n$$R = \\begin{pmatrix}\n\n\\cos(\\omega) & -\\sin(\\omega) \\\\\n\\sin(\\omega) & \\cos(\\omega)\n\\end{pmatrix},$$\nwhere $\\omega$ is the frequency of the seasonality. In practice, it is easier to specify the period of the seasonality, $T$, which is related to the frequency: $\\omega = 2 \\pi/T$. This means if we have data measured at hourly intervals and we believe the process has a daily cycle, then we will set $T = 24$.\n\nIn order to model higher harmonics of the seasonality, we combine rotation matrices together into a block diagonal matrix, to form the $G$ matrix, for instance with 3 harmonics the system matrix is:\n\n\n$$G = \\begin{pmatrix}\n\\cos(\\omega) & -\\sin(\\omega) & 0 & 0 & 0 & 0\\\\\n\\sin(\\omega) & \\cos(\\omega) & 0 & 0 & 0 & 0 \\\\\n0 & 0 & \\cos(2\\omega) & -\\sin(2\\omega) & 0& 0 \\\\\n0 & 0 & \\sin(2\\omega) & \\cos(2\\omega) & 0 & 0 \\\\\n0 & 0 & 0 & 0 & \\cos(3\\omega) & -\\sin(3\\omega) \\\\\n0 & 0 & 0 & 0 & \\sin(3\\omega) & \\cos(3\\omega) \\\\\n\\end{pmatrix}.$$\n\nIn this case, the latent state, $x_t$ is six-dimensional. This means system evolution variance-covariance matrix, $W_t$ is a six by six matrix.\n\nFirst we should make a `case class` in Scala representing a DLM. A `case class` in Scala is a class with a default `apply` method used to construct instances of the class. The `case class` also has getter methods which can be used to access the values of the class. The `case class` will be for a DLM with constant $F$ and $G$ matrices. \n\n```scala\nimport breeze.linalg._\n\ncase class Dlm(f: DenseMatrix[Double], g: DenseMatrix[Double])\n```\n\nNote that, for univariate observations $F$ will be a row vector, the recommended way to specify row vectors using [Breeze](https://github.com/scalanlp/breeze/) is to use a matrix with a single row. The DLM also has associated parameters which we will assume are constant and write as a `case class`.\n\n```scala\ncase class Parameters(v: Double, w: DenseMatrix[Double], m0: DenseVector[Double], c0: DenseMatrix[Double])\n```\n\nThen we can add a method to simulate forward given a value of the `Parameters`, firstly we will write a single step of the simulation:\n\n```scala\ncase class Data(time: Double, observation: Double, state: DenseVector[Double])\n\ndef simStep(p: Parameters, model: Dlm): Data => Rand[Data] = d => {\n    for {\n      w <- MultivariateGaussian(DenseVector.zeros(p.w.cols), p.w)\n      x1 = model.g * d.state + w\n      v <- Gaussian(0, p.v)\n      y = model.f.toDenseVector dot x1 + v\n    } yield Data(d.time + 1.0, y, x1)\n  }\n```\n\nThis function contains a for comprehension, the `<-` symbol represents either a `map` or a `flatMap`. Since the `w` and `v` are `Rand[Double]` values, we need to access the value inside of the `Rand` and perform a function on it, the for comprehension desugars to:\n\n```scala\nMultivariateGaussian(DenseVector.zeros(p.w.cols), p.w).\n  flatMap(w => {\n    val x1 = model.g * d.state + w\n    Gaussian(0, p.v).map(v => {\n      val y = model.f.toDenseVector dot x1 + v\n      Data(d.time + 1.0, y, x1)\n    })}\n    )\n```\n\nThe desugared chain of `flatMap` and `map` evaluates to the same result, but the for-comprehension is more readable. This syntax provides a clean and elegent way to work within the context of a Monad, `Rand` is an example of a Monad representing a distribution.\n\nNow, we can use the `MarkovChain` breeze object to simulate the full series:\n\n```scala\ndef simMarkov(p: Parameters, model: Dlm): Rand[Process[Data]] = {\n  for {\n    x0 <- MultivariateGaussian(p.m0, p.c0)\n    y0 <- Gaussian(model.f.toDenseVector dot x0, p.v)\n    init = Data(0.0, y0, x0)\n  } yield MarkovChain(init)(simStep(p, model))\n}\n```\n\nNote that the Markov chain is a `Rand[Process[Double]]`, this is not the most elegant and I'm open to suggestions on a better way to formulate this. Once we have defined a Markov chain, we must draw from it which returns a `Process[Double]`, the initial draw is to sample from the initial state distribution $\\mathcal{N}(m_0, C_0)$. Next, we can sample from the `Process` and plot it. A simulation from the seasonal DLM, with parameters $V = 3$ and $W = I_6$, is given below:\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}