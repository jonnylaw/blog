{
  "hash": "c0d7da7d4f5ca396609dc07d87ab9829",
  "result": {
    "markdown": "---\ntitle: \"Gibbs Sampling for the Hidden Markov Model\"\ndescription: |\n  \"Determining the parameters of a simple HMM using functional programming in R.\"\nauthor: \"Jonny Law\"\ndate: 2020-07-30\ncategories:\n  - [R, Bayesian]\n---\n\n\n\n\nIn this post we will consider the backward smoothing algorithm for a hidden Markov model (HMM). While exploring the derivation and implementation we will consider how to avoid the use of mutable state and implement the algorithm in a purely functional way. This post follows from the previous post discussing [hidden Markov models] and functional programming, the inference scheme developed in that post was a Metropolis-Hastings algorithm where the marginal likelihood calculated using the HMM forward algorithm.\n\nWe will consider another parameter inference algorithm, a Gibbs sampling algorithm targeting the posterior distribution of the transition matrix.\n\n## Simple HMM\n\nThe transition matrix used to simulate the sequence of states and observations is\n\n\n$$P = \\begin{pmatrix}\n0.5 & 0.5 \\\\\n0.4 & 0.6\n\\end{pmatrix}$$\n\nThe emission matrix used to simulate the sequence of states and observations is\n\n$$B = \\begin{pmatrix}\n\n0.2 & 0.8 \\\\\n0.9 & 0.1\n\\end{pmatrix}.$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nP <- matrix(c(0.5, 0.5, 0.4, 0.6), byrow = T, ncol = 2)\nB <- matrix(c(0.2, 0.8, 0.9, 0.1), byrow = T, ncol = 2)\nsimple_hmm <-\n  hmm_simulate(300, c(1, 0), P, function(state)\n    sample(1:2, size = 1, prob = B[state, ]))\n\nsimple_hmm %>% \n  filter(time < 100) %>% \n  pivot_longer(-time, values_to = \"value\", names_to = \"key\") %>% \n  ggplot(aes(x = time, y = value)) +\n  geom_step() +\n  facet_wrap(~key, ncol = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nFirst we calculate the number of state transitions. We can use the function `reduce2`, which starts with two initial values and accepts a reduction function of the form `(accumulator, from, to) -> new_accumulator`. We have the sequence of observations of the discrete hmm, we simply initialise a matrix of zeros with the same dimension as the number of states as the accumulator and add one to the entry in the matrix each time we see a given transition. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_transitions <- function(\n  n_states,\n  states) {\n  n <- length(states)\n  zeros <- matrix(0, nrow = n_states, ncol = n_states)\n  \n  purrr::reduce2(states[-n], states[-1], function(acc, from, to) {\n    acc[from, to] <- acc[from, to] + 1\n    acc\n  }, .init = zeros)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_transitions(2, simple_hmm$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]  108   69\n[2,]   69   53\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfwd <- hmm_forward(simple_hmm$y, x0 = c(0, 1), transition_matrix = P, observation = function(y) B[,y])\ntibble(\n  time = seq_len(length(fwd)),\n  filtered_state = purrr::map_dbl(fwd, which.max),\n  p_state1 = purrr::map_dbl(fwd, ~ .[1])\n) %>% \n  inner_join(simple_hmm, by = \"time\") %>% \n  pivot_longer(c(\"x\", \"y\", \"p_state1\", \"filtered_state\"), names_to = \"key\", values_to = \"value\") %>% \n  ggplot(aes(x = time, y = value)) +\n  geom_step() +\n  facet_wrap(~key, ncol = 1, scales = \"free_y\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/filtered-state-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhmm_backward_step <- function(beta, y, transition_matrix, observation) {\n  normalise(transition_matrix %*% (observation(y) * beta))\n}\n\nhmm_backward <- function(ys, transition_matrix, observation) {\n  purrr::accumulate(\n    rev(ys),\n    hmm_backward_step,\n    observation = observation, \n    transition_matrix = transition_matrix,\n    .init = c(1, 1)\n  ) %>% rev()\n}\n\nhmm_forward_backward <- function(ys, x0, transition_matrix, observation) {\n  n <- length(ys)\n  f <- hmm_forward(ys, x0, transition_matrix, observation)\n  b <- hmm_backward(ys, transition_matrix, observation)\n  purrr::map2(f, b[-(n+1)], ~ jonnylaw:::normalise(.x * .y))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbackward <- hmm_backward(ys = simple_hmm$y, transition_matrix = P, observation = function(y) B[,y])\n\np1 <- tibble(\n  time = seq_len(length(fwd)),\n  smoothed_p_state1 = purrr::map_dbl(backward, ~ .[1])[-301],\n  filtered_p_state1 = purrr::map_dbl(fwd, ~ .[1])\n) %>% \n  inner_join(simple_hmm, by = \"time\") %>% \n  pivot_longer(c(\"smoothed_p_state1\", \"filtered_p_state1\"), names_to = \"key\", values_to = \"value\") %>% \n  ggplot(aes(x = time, y = value)) +\n  geom_step() +\n  facet_wrap(~key, ncol = 1)\n\np2 <- tibble(\n  time = seq_len(length(fwd)),\n  smoothed_p_state1 = purrr::map_dbl(backward, ~ .[1])[-301],\n  filtered_p_state1 = purrr::map_dbl(fwd, ~ .[1])\n) %>% \n  inner_join(simple_hmm, by = \"time\") %>% \n  pivot_longer(c(\"x\", \"y\"), names_to = \"key\", values_to = \"value\") %>% \n  ggplot(aes(x = time, y = value)) +\n  geom_step() +\n  facet_wrap(~key, ncol = 1)\n\ngridExtra::grid.arrange(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/smoothed-state-1.png){width=672}\n:::\n:::\n\n\n## Gibbs Sampler\n\nCalculate $p(z_t = i | z_{t+1} = j, y_{1:T})$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhmm_backward_sample_step <- function(\n   sampled_state,\n   y1,\n   alpha,\n   alpha1,\n   transition_matrix,\n   observation) {\n   observation_dist <- observation(y1)\n   transition <- transition_matrix[sampled_state, ]\n\n   probs <- ((observation_dist %*% transition) * alpha) / alpha1\n\n   sample(x = seq_len(length(probs)), size = 1, prob = probs)\n }\n```\n:::\n\n\nFunctional Backward sampling, we must `reduce` while collecting the intermediate results in a list. \n\n\n::: {.cell}\n\n```{.r .cell-code}\naccumulate3 <- function(x, y, z, f, ..., init, direction = \"forward\") {\n  res <- list()\n  res[[1]] <- init\n  for (i in seq_len(length(x)) + 1) {\n     res[[i]] <- f(res[[i-1]], x[[i-1]], y[[i-1]], z[[i-1]], ...)\n  }\n  res\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naccumulate3(x = 1:10, y = 1:10, z = 1:10, f = function(init, x, y, z) init + x + y + z, init = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 0\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 18\n\n[[5]]\n[1] 30\n\n[[6]]\n[1] 45\n\n[[7]]\n[1] 63\n\n[[8]]\n[1] 84\n\n[[9]]\n[1] 108\n\n[[10]]\n[1] 135\n\n[[11]]\n[1] 165\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhmm_backward_sample <- function(ys,\n                               alphas, # matrix of forward filtered probabilities\n                               transition_matrix,\n                               observation) {\n d <- ncol(alphas)\n n <- length(ys)\n sample_last <- sample(seq_len(d), size = 1, prob = alphas[n,])\n \n accumulate3(\n   rev(ys),\n   y = alphas[-n,],\n   z = alphas[-1,],\n   hmm_backward_sample_step,\n   transition_matrix = transition_matrix, \n   observation = observation, \n   init = sample_last\n )\n}\n```\n:::\n\n\n\n\nSample a value of the latent-state of an HMM\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhmm_forward_backward_sample <- function(ys,\n                                        x0,\n                                        observation,\n                                        transition_matrix) {\n  alphas <- hmm_forward(ys, x0, transition_matrix, observation)\n  alphas <- matrix(unlist(alphas), ncol = length(x0), nrow = length(ys), byrow=TRUE)\n  hmm_backward_sample(ys, alphas, transition_matrix, observation)\n}\n```\n:::\n\n\nSample a value of the transition matrix from a product of Dirichlet distributions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_transition <- function(alpha, n_states) {\n  out <- matrix(NA_real_, ncol = n_states, nrow = n_states)\n  for (i in seq_len(n_states)) {\n    out[i, ] <- MCMCpack::rdirichlet(1, alpha)\n  }\n  out\n}\n\nsample_theta <- function(xs, alpha, n_states) {\n  state_transitions_mat <- state_transitions(n_states, xs)\n  out <- matrix(NA_real_, ncol = n_states, nrow = n_states)\n  for (i in seq_len(n_states)) {\n    out[i, ] <- MCMCpack::rdirichlet(1, alpha + state_transitions_mat[i, ])\n  }\n  out\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngibbs_step <- function(alpha,\n                       ys,\n                       x0,\n                       observation,\n                       xs) {\n  transition_matrix <- sample_theta(xs, alpha, length(x0))\n  new_state <-\n    hmm_forward_backward_sample(ys, x0, observation, transition_matrix)\n  list(m = transition_matrix, state = new_state)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n gibbs_hmm <- function(\n   alpha,\n   ys,\n   x0,\n   observation, \n   iters = 10) {\n   n_states <- length(x0)\n   transition_matrix <- sample_transition(alpha, length(x0))\n   xs <- hmm_forward_backward_sample(ys, x0, observation, transition_matrix)\n   out <- list()\n   for (i in seq_len(iters)) {\n     out[[i]] <- gibbs_step(alpha, ys, x0, observation, xs)\n     xs <- out[[i]]$state\n   }\n   out\n }\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- gibbs_hmm(\n  alpha = c(1.0, 1.0), \n  ys = simple_hmm$y,\n  x0 = c(0.5, 0.5), \n  observation = function(x) B[,x])\n\nmap(out, \"m\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n          [,1]        [,2]\n[1,] 0.9950037 0.004996327\n[2,] 0.2174366 0.782563431\n\n[[2]]\n          [,1]       [,2]\n[1,] 0.9944118 0.00558819\n[2,] 0.7377959 0.26220413\n\n[[3]]\n          [,1]        [,2]\n[1,] 0.9969703 0.003029693\n[2,] 0.8083055 0.191694473\n\n[[4]]\n          [,1]        [,2]\n[1,] 0.9951793 0.004820735\n[2,] 0.2286120 0.771388026\n\n[[5]]\n          [,1]        [,2]\n[1,] 0.9966060 0.003394003\n[2,] 0.8769933 0.123006717\n\n[[6]]\n           [,1]        [,2]\n[1,] 0.99903441 0.000965588\n[2,] 0.03421011 0.965789894\n\n[[7]]\n           [,1]        [,2]\n[1,] 0.99458448 0.005415523\n[2,] 0.09123251 0.908767486\n\n[[8]]\n          [,1]        [,2]\n[1,] 0.9986854 0.001314614\n[2,] 0.6727422 0.327257756\n\n[[9]]\n          [,1]        [,2]\n[1,] 0.9988522 0.001147789\n[2,] 0.6570719 0.342928111\n\n[[10]]\n          [,1]        [,2]\n[1,] 0.9950587 0.004941277\n[2,] 0.8990846 0.100915373\n```\n:::\n:::\n\n\n# Functional sampling\n\n\n::: {.cell}\n\n```{.r .cell-code}\niterate_dbl <- function(init, f, ..., n) {\n  i <- 2\n  out <- numeric(n)\n  out[1] <- init\n  while (i <= n) {\n    out[i] <- f(out[i-1])\n    i <- i + 1\n  }\n  out\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niterate_dbl(0, function(x) x + 1, n=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 1 2 3 4 5 6 7 8 9\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}