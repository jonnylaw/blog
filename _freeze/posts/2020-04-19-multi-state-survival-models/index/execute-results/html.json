{
  "hash": "c0b2edf78465268e0b1cfbd80d57d1a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Multi State Models\ndate: '2020-04-19'\nslug: multi-state-survival-models\ncategories: \n  - R\n  - Bayesian\nfreeze: auto\n---\n\n\n\nMulti-state models are used to model disease progression. The model is a continuous time Markov process. The states and time of transitions are fully observed. There are three states a patient can be in, \"healthy\", \"illness\" and \"deceased\". The possible pairs of transitions between these states include healthy -> illness, illness -> healthy, illness -> death and healthy -> death. The model can be expressed as a directed graph.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/multi-state-1.png){width=90%}\n:::\n:::\n\n\nThe state \"Deceased\" is an absorbing state, whereas the other two states are transient. This means we can't transition away from the Deceased state. \n\nThe process is a Markov process, it has a transition kernel, $p(x_{i,t_j}|x_{i,t_{j-1}}, \\theta)$ which depends only on the previous state and some static parameters $\\theta$. The state for the $i^{\\text{th}}$ patient at time $t_j$ is written $x_{i,t_j}$. The parameters for the transition kernel populate the transition rate matrix. The rate matrix is the derivative of the transition kernel at $t=0$\n\n$$\\begin{aligned}\nQ &= \\frac{d}{dt}P(t)\\Bigr|_{\\substack{t=0}} \\\\\n&= \\lim_{\\delta t \\rightarrow 0}\\frac{P(\\delta t) - P(0)}{\\delta t} \\\\\n&= \\lim_{\\delta t \\rightarrow 0}\\frac{P(\\delta t) - I}{\\delta t}\n\\end{aligned}$$\n\nThen we can rearrange for the transition kernel,\n\n$$P(\\delta t) = I + Q \\delta t.$$\n\nThis gives the infinitesimal transition for a very small time increment. Using this result, we can solve for the transition kernel over a finite time\n\n$$\\begin{aligned}\n\\frac{d}{dt}P(t) &= \\frac{P(t + dt) - P(t)}{dt} \\\\\n&= \\frac{P(dt)P(t) - P(t)}{dt}\\\\\n&= \\frac{(P(dt) - I)}{dt}P(t)\\\\\n&= QP(t).\n\\end{aligned}$$\n\nThen solve the resulting differential equation to see that $P(t) = \\exp(Qt)$, hence the transition matrix is the matrix exponential of the transition rate matrix. The transition rate matrix for this problem can be written as\n\n$$\nQ = \\begin{pmatrix} \n-\\sum_{j\\neq 1}q_{1j} & q_{12} & q_{13} \\\\\nq_{21} & -\\sum_{j\\neq 2}q_{2j} & q_{13} \\\\\n0 & 0 & 0 \n\\end{pmatrix}\n$$\n\nThe non-zero elements of the rate-matrix are potential transitions. The final state is absorbing - hence we can't transition from it.\n\n## Simulating Data from the Model\n\nWe can simulate forward using a grid of times, $t_i = t_0, \\dots, t_n$ where $t_i - t_{i-1} = \\Delta t$ is a small time increment, using the exact solution for the transition rate matrix $P(\\Delta t) = \\exp(Q \\Delta t)$.\n\n1. Sample the rate parameters from the prior distribution\n2. Construct a rate matrix from each sample\n3. Compute the matrix exponential and simulate forward conditional on the previous step\n\nForward simulation is drawing next state, $x_t$ from a categorical distribution with probabilities from the row of the transition matrix corresponding to the state at time $t-1$, $P(\\Delta t)_{x_{t-1}\\cdot}$.\n\nWe use Gamma priors for the non-zero elements of the rate matrix:\n\n$$\\begin{aligned}\nq_{12} &\\sim \\textrm{Gamma}(3, 3/0.05)\\\\\nq_{13} &\\sim \\textrm{Gamma}(3, 3/0.001)\\\\\nq_{21} &\\sim \\textrm{Gamma}(3, 3/0.02)\\\\\nq_{23} &\\sim \\textrm{Gamma}(3, 3/0.01)\n\\end{aligned}$$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- jonnylaw::plot_pdf(dgamma, 3, 3/0.05, range = c(0, 0.5), title = \"Gamma prior for q_{12}\")\np2 <- jonnylaw::plot_pdf(dgamma, 3, 3/0.001, range = c(0, 0.1), title = \"Gamma prior for q_{13}\")\np3 <- jonnylaw::plot_pdf(dgamma, 3, 3/0.02, range = c(0, 0.2), title = \"Gamma prior for q_{21}\")\np4 <- jonnylaw::plot_pdf(dgamma, 3, 3/0.01, range = c(0, 0.1), title = \"Gamma prior for q_{23}\")\n\n(p1 | p2) / (p3 | p4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sample from the prior for lambda\nmeans <- c(0.05, 0.001, 0.02, 0.01)\nlambdas <- purrr::map_dbl(means, ~ rgamma(1, shape = 3, rate = 3/.))\n```\n:::\n\n\nThe following function populates a rate matrix given a vector of hazards.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuild_rate_matrix <- function(lambda, n_states = 3, n_absorbing = 1) {\n  q <- matrix(rep(0, times = n_states * n_states), byrow = TRUE, nrow = n_states)\n  k <- 1\n  for (i in 1:n_states) {\n    for (j in 1:n_states) {\n      if (i != j & i <= (n_states - n_absorbing)) {\n        q[i, j] = lambda[k]\n        k = k + 1\n      }\n    }\n  }\n  \n  ## fix the diagonal to be negative the sum of the remaining elements in the row\n  diag(q) = -rowSums(q)\n  q\n}\n```\n:::\n\n\nThe next function can be used to simulate the process on a grid of times $t_1, \\dots, t_n$. The step-size between each realisation must be small enough to see any transitions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulate the markov chain\nsim_markov <- function(lambdas, step_size, n_steps) {\n  state <- numeric(n_steps)\n  \n  ## Build the rate and transition matrices\n  rate_matrix <- build_rate_matrix(lambdas)\n  transition_matrix <- Matrix::expm(rate_matrix * step_size)\n  n_states <- nrow(rate_matrix)\n  \n  # initial state is always healthy\n  state[1] <- 1\n\n  for (i in 2:n_steps) {\n    state[i] <- sample(x = n_states, size = 1, prob = transition_matrix[state[i-1], ])\n  }\n  tibble(time = seq_len(n_steps), state = state)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nlambdas <- matrix(replicate(n = 1000, purrr::map_dbl(means, ~ rgamma(1, shape = 3, rate = 3/.))), ncol = 4, byrow = TRUE)\nreplicates <- apply(lambdas, 1, function(x) sim_markov(x, 0.1, 50)) %>% \n  bind_rows(.id = \"replicate\")\n```\n:::\n\n\nSimulating 1,000 trajectories for (50 * 0.1 = 5 days) transitions results in the following state transitions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplicates %>% \n  group_by(replicate) %>% \n  mutate(from = lag(state), to = state) %>% \n  drop_na() %>% \n  count(from, to) %>% \n  arrange(to) %>% \n  pivot_wider(names_from = \"to\", values_from = \"n\", values_fill = 0) %>% \n  group_by(from) %>% \n  summarise_at(vars(`1`:`3`), sum) %>% \n  arrange(from)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n   from   `1`   `2`   `3`\n  <dbl> <int> <int> <int>\n1     1 43000   227     1\n2     2    11  5700     2\n3     3     0     0    59\n```\n\n\n:::\n:::\n\n\nInstead of simulating on a fine grid we can use discrete event simulation to simulate the exact process:\n\n* Given the initial state is $i$\n* Simulate the time to the next event, $t \\sim \\text{Exp}(-q_{ii})$\n* Simulate the next state by simulating from a distribution with pmf $q_{ij} / q_{ii}, i \\neq j$\n* Return the sample path if we have landed in an absorbing state, $q_{ii} = 0$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_exact <- function(x, Q, n) {\n  xs = numeric(n + 1)\n  ts = numeric(n)\n  r = nrow(Q)\n  t = 0\n  ts[1] <- t\n  xs[1] = x\n  for (i in seq_len(n)) {\n    t <- t + rexp(1, -Q[x, x]) # Sim time to next observation\n    weights <- Q[x, ] # Calculate the probability of transitioning away to another state\n    weights[x] <- 0 # We can't stay in the same state\n    x <- sample(r, 1, prob = weights) # Sample the next state\n    xs[i + 1] <- x # add to vector of states\n    ts[i + 1] <- t # add to vector of event times\n    if (Q[x, x] == 0) { # If the new state is an absorbing state then return event times\n      return(tibble(time = ts[seq_len(i + 1)], state = xs[seq_len(i + 1)]))\n    }\n  }\n  tibble(time = ts, state = xs) # Return event times without absorbing\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\nreplicates <- apply(lambdas, 1, function(lambda) {\n  Q <- build_rate_matrix(lambda)\n  sim_exact(1, Q, 20)\n}) %>% \n  bind_rows(.id = \"replicate\")\n\nqs <- replicates %>% \n  group_by(replicate) %>% \n  mutate(from = lag(state), to = state) %>% \n  drop_na() %>% \n  count(from, to) %>% \n  arrange(to) %>% \n  pivot_wider(names_from = \"to\", values_from = \"n\", values_fill = 0) %>% \n  group_by(from) %>% \n  summarise_at(vars(`1`:`3`), sum) %>% \n  arrange(from) %>% \n  select(-1) %>% \n  as.matrix()\nqs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        1    2   3\n[1,]    0 3019  80\n[2,] 2150    0 869\n```\n\n\n:::\n:::\n\n\nThe figure below shows the mean time in each state with 66% and 95% credible intervals. This is calculated by sampling 1,000 rate matrices from the prior distribution and calculating $1 /  q_i = \\sum_{j\\neq i}q_{ij}$ using each sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlambdas %>% \n  as_tibble() %>% \n  rename(lambda1 = V1, lambda2 = V2, lambda3 = V3, lambda4 = V4) %>% \n  mutate(healthy = 1 / (lambda1 + lambda2),\n         illness = 1 / (lambda3 + lambda4)\n         ) %>% \n  pivot_longer(healthy:illness, names_to = \"state\", values_to = \"value\") %>% \n  group_by(state) %>% \n  tidybayes::median_qi(value, .width = c(0.66, 0.95)) %>% \n  ggplot(aes(x = state, y = value, ymin = .lower, ymax = .upper)) +\n  tidybayes::geom_pointinterval() +\n  labs(x = \"Days\", title = \"Distribution of the mean time in each state.\") +\n  coord_flip()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/mean-time-states-1.png){width=672}\n:::\n:::\n\n\n### Simulating a real-world example\n\nIn a real world example patients are observed at a different number of times, $n_i$ represents the number of state observations for patient $i$. To simulate realistic data we will randomise the number of steps recorded for each \"patient\" using the exact algorithm. Let's sample the number of steps uniformly between 1 and 5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nlambda <- c(0.05, 0.01, 0.2, 0.2)\nnames(lambda) <- paste0(\"lambda\", 1:4)\nQ <- build_rate_matrix(lambda)\nsims <- purrr::map_dfr(\n  as.list(sample(5, size = 100, replace = TRUE)),\n  ~ sim_exact(1, Q, .),\n  .id = \"patient\")\n```\n:::\n\n\nThe plot below shows patient journeys for patients 3, 11, 13 and 100. Patient 3 has only two observed state changes and censoring on the final state. Patient 11 has multiple observed transitions through illness and healthy, then a final transition to the absorbing state. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsims %>% \n  filter(patient %in% c(3, 11, 13, 100)) %>% \n  ggplot(aes(x = time, y = state)) +\n  geom_step() +\n  facet_wrap(~patient, scales = \"free_x\") +\n  labs(title = \"Patient Journeys for Selected Patients\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWe can write down the likelihood for the $i^{\\text{th}}$ patient with state transitions at times, $t_{ij}, j = 0,\\dots,n_i$\n\n$$\\begin{aligned}\np(X_{i,t_{0:n_i}}|Q) &= p(x_{i,0})\\prod_{j=1}^{n_i}p(x_{i,t_j}|x_{i,t_{j-1}}, Q) \\\\\n&= \\prod_{j=1}^{n_i}\\exp(Q(t_{ij} - t_{ij-1}))_{x_{i,t_j},x_{i,t_{j-1}}}\n\\end{aligned}$$\n\nThe initial state is fixed at one and the transition kernel is given by the matrix exponential of the rate matrix. There is one problem with this likelihood: It does not incorporate censored paths. \n\nA multi-state model such as this can be thought of as multiple survival models. I introduced [Survival models](/blog/bayesian-survival-analysis/) in a previous blog post. In a survival model, the transition is governed by a hazard function. The hazard function for transitioning to state $j$ from state $i$ is\n\n$$H_{ij}(t_1, t_2) = \\int_{u=t_1}^{t_2} q_{ij}\\, du = (t_2-t_1)q_{ij}.$$\n\nThe Survival function, $Pr(T > t)$ is:\n\n$$S_{ij}(t) = \\exp(-H_{ij}(0, t)) = \\exp(-tq_{ij})$$\n\nThe pdf is $f_{ij}(t) = \\frac{d}{dt}F_{ij}(t)$ where $F_{ij}(t) = 1 - S_{ij}(t)$,\nhence $f_{ij} = q_{ij}\\exp(-tq_{ij})$.\n\nLet's consider the likelihood for patient 13.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsims %>% \n  filter(patient == 13) %>% \n  knitr::kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|patient | time| state|\n|:-------|----:|-----:|\n|13      | 0.00|     1|\n|13      | 3.93|     2|\n|13      | 8.20|     1|\n\n\n:::\n:::\n\n\nFor each state transition all other possible transitions are considered censored. The data-frame for patient 13 can be re-written by first considering a data-frame of all possible transitions and determining which transitions end in an absorbing state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npossible_transitions <- \n  tibble(\n    from = c(1, 1, 2, 2),\n    to = c(2, 3, 1, 3),\n    absorbing = c(FALSE, TRUE, FALSE, TRUE)\n  )\n```\n:::\n\n\nWe can then create a \"from\" column representing the previous state of a transition, then left join the possible states using \"from\". Observed states are when the \"to\" in both tables match, censored states are non-matching.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsims %>% \n  filter(patient == 13) %>% \n  mutate(from = lag(state)) %>% \n  rename(to = state) %>% \n  left_join(possible_transitions, by = \"from\") %>% \n  mutate(observed = to.x == to.y) %>% \n  knitr::kable(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|patient | time| to.x| from| to.y|absorbing |observed |\n|:-------|----:|----:|----:|----:|:---------|:--------|\n|13      | 0.00|    1|   NA|   NA|NA        |NA       |\n|13      | 3.93|    2|    1|    2|FALSE     |TRUE     |\n|13      | 3.93|    2|    1|    3|TRUE      |FALSE    |\n|13      | 8.20|    1|    2|    1|FALSE     |TRUE     |\n|13      | 8.20|    1|    2|    3|TRUE      |FALSE    |\n\n\n:::\n:::\n\n\nThis layout explicitly allows us to see which state transitions are observed and which are censored. Patient 13 starts in state 1, as do all patients. The first observation at time $t = 3.92$ is a transition from $1 \\rightarrow 2$, illness - this observation implies a censored observation for the transition $1 \\rightarrow 3$. Then we transition from state 2 back to state 1 and never observe the terminal state.\n\n$$\\begin{aligned}\np(X_{i=13,t_{0:3}}|Q) &= Pr(X_{t_1} = 2|X_{t_0} = 1)Pr(X_{t>t_1} = 3)Pr(X_{t_2} = 1|X_{t_1} = 2)Pr(X_{t>t_2} = 3) \\\\\n&=f_{12}(t_1-t_0)S_{13}(t_1-t_0)f_{21}(t_2-t_1)S_{23}(t_2-t_1) \\\\\n&=q_{12}\\exp(-q_{12}(t_1-t_0))\\exp(-(t_1-t_0)q_{13})q_{21}\\exp(-q_{21}(t_2-t_1))\\exp(-(t_2-t_1)q_{23}) \\\\\n&= q_{12}q_{21}\\exp(-q_{12}(t_1-t_0) -(t_1-t_0)q_{13} -q_{21}(t_2-t_1) -(t_2-t_1)q_{23}) \\\\\n&= q_{12}q_{21}\\exp(-(q_{12} + q_{13})(t_1-t_0) - (q_{21} + q_{23})(t_2-t_1))\n\\end{aligned}$$\n\nThe final line shows that the likelihood consists of the hazards of the observed transitions $1 \\rightarrow 2$ and $2 \\rightarrow 1$, multiplied by the exponential of the sum of the off-diagonal elements of the rate matrix multiplied by the total time those states have been observed.\n\nThis can be generalised:\n\n$$p(X_{i,t_{0:3}}|Q) = \\prod_{j=1}^3\\prod_{k=1,k\\neq j}^3q_{jk}^{n_{ijk}}\\exp(-\\tau_{ij}q_j)$$\n\nWhere $q_j = \\sum_{j=1,j\\neq k}^3q_{jk}$, $\\tau_{ij}$ is the time in the $j^{\\text{th}}$ state for patient $i$ and $n_{ijk}$ is a matrix with a count of the number of transitions from state $j$ to state $k$. We can then calculate the likelihood for all patients:\n\n$$\\begin{aligned}\np(\\textbf{X}_t|Q) &= \\prod_{i=1}^N\\prod_{j=1}^3\\prod_{k=1,k\\neq j}^3q_{jk}^{n_{ijk}}\\exp(-\\tau_{ij}q_j)\\\\\n&= \\prod_{j=1}^3\\prod_{k=1,k\\neq j}^3q_{jk}^{n_{1jk} + \\dots + n_{Njk}}\\exp(-\\sum_{i=1}^N\\tau_{ij}q_j)\\\\\n&= \\prod_{j=1}^3\\prod_{k=1,k\\neq j}^3q_{jk}^{n_{jk}}\\exp(-\\tau_{j}q_j)\\\\\n\\end{aligned}$$\n\nWhere, $n_{jk}$ is the sum of all $N$ matrices representing the transitions $j \\rightarrow k$ and $\\tau_j$ is the total time spent in state $j$ for all patients.\n\nFor reasons of numerical stability, the log-likelihood is used,\n\n$$\\begin{aligned}\n\\log p(\\textbf{X}_t|Q) &= \\sum_{j=1}^3\\sum_{k=1,k\\neq j}^3\\left(n_{jk}\\log(q_{jk})-\\tau_jq_j\\right).\n\\end{aligned}$$\n\n## Parameter Inference\n\nThe posterior distribution of the free parameters in the rate matrix is determined using a random walk Metropolis algorithm. The prior distribution for the rate parameters are independent Gamma distributions parameterised with shape, $\\alpha$ and rate, $\\beta$ such that the mean is $\\alpha/\\beta$\n\n$$\\lambda_i \\sim \\text{Gamma}\\left(3, \\frac{3}{0.01}\\right), \\quad i = 1,\\dots,12.$$\n\nThe rate parameters are transformed to the log scale and the proposal distribution is a symmetric Normal distribution centered at the value of the previously accepted parameter at iteration $k-1$\n\n$$\\log\\lambda_k \\sim \\text{MVN}(\\log\\lambda_{k-1}, I_{4}\\delta), \\quad \\delta = 0.01.$$\n\nwhere $\\delta$ is a tuning parameter of the MCMC and $I_{4}$ represents the 4 dimensional identity matrix.\n\nCalculate the total-time in each state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_in_state <- sims %>% \n  group_by(patient) %>%\n  mutate(total_time = lead(time) - time) %>% # Time in state\n  group_by(state) %>% \n  summarise(total_time = sum(total_time, na.rm = TRUE))\n\ntime_in_state %>% knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| state| total_time|\n|-----:|----------:|\n|     1|  2284.0808|\n|     2|   189.7724|\n|     3|     0.0000|\n\n\n:::\n\n```{.r .cell-code}\ntau <- time_in_state %>% \n  purrr::pluck(\"total_time\")\n```\n:::\n\n\nCalculate the matrix of observed transitions. Note that no transitions occur from state 3, the absorbing state.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobserved_transitions <- sims %>% \n  group_by(patient) %>% \n  mutate(from = lag(state), to = state) %>% \n  drop_na() %>% \n  count(from, to) %>% \n  arrange(to) %>% \n  pivot_wider(names_from = \"to\", values_from = \"n\", values_fill = 0) %>% \n  group_by(from) %>% \n  summarise_at(vars(`1`:`3`), sum) %>% \n  arrange(from) %>% \n  select(-1) %>% \n  as.matrix\n(observed_transitions <- rbind(observed_transitions, c(0, 0, 0)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      1   2  3\n[1,]  0 107 21\n[2,] 38   0 43\n[3,]  0   0  0\n```\n\n\n:::\n:::\n\n\nProgram the log-likelihood, prior and proposal distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## rate_matrix is the constructed rate-matrix\n## tau is a vector containing total time in each state\n## observed_transitions is a matrix with all observed transitions\n## with the state from in the rows and state to in the columns.\nlog_likelihood <- function(rate_matrix, tau, observed_transitions) {\n  n_states <- nrow(rate_matrix)\n  qi <- - diag(rate_matrix)\n  sum(log(rate_matrix - diag(diag(rate_matrix))) * observed_transitions, na.rm = TRUE) - (n_states - 1) * sum(qi * tau)\n}\n\nlog_prior <- function(lambda) {\n  sum(dgamma(lambda, shape = 3, scale = 3 / 0.1, log = TRUE))\n}\n\nproposal <- function(lambda) {\n  lambda * exp(rnorm(4, sd = 0.01))\n}\n\nlog_posterior <- function(lambda) {\n    Q <- build_rate_matrix(lambda)\n    log_likelihood(Q, tau, observed_transitions) + log_prior(lambda)\n  }\n```\n:::\n\n\nWe are ready to sample from the posterior distribution of the rate parameters using the Metropolis algorithm. We run four chains in parallel using [furrr](https://davisvaughan.github.io/furrr/) as explained in [my previous post](/blog/efficient_mcmc_using_rcpp/) on efficient MCMC in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niters <- jonnylaw::metropolis(\n  lambda,\n  log_posterior,\n  proposal,\n  m = 1e5, \n  chains = 4, \n  parallel = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 method overwritten by 'future':\n  method               from      \n  all.equal.connection parallelly\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'future' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'purrr' was built under R version 4.3.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: UNRELIABLE VALUE: Future (NULL) unexpectedly generated random numbers\nwithout specifying argument 'seed'. There is a risk that those random numbers\nare not statistically sound and the overall results might be invalid. To fix\nthis, specify 'seed=TRUE'. This ensures that proper, parallel-safe random\nnumbers are produced. To disable this check, use 'seed=NULL', or set option\n'future.rng.onMisuse' to \"ignore\".\n```\n\n\n:::\n:::\n\n\nThe posterior diagnostics are plotted below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niters %>% \n  group_by(chain) %>% \n  mutate(iteration = row_number()) %>% ## Add iteration number\n  filter(iteration > 5e4) %>% \n  jonnylaw::thin(10) %>%  ## Reduce things to plot\n  pivot_longer(-c(\"chain\", \"iteration\", \"accepted\"), names_to = \"parameter\", values_to = \"value\") %>% \n  jonnylaw::plot_diagnostics()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nThe plot below shows posterior distribution of the mean time in each state, $1 / q_i$. The blue points are the actual observed values of each patient.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_in_state <- sims %>% \n  group_by(patient) %>%\n  mutate(total_time = lead(time) - time) %>% \n  mutate(state = case_when(\n    state == 1 ~ \"healthy\",\n    state == 2 ~ \"illness\",\n    TRUE ~ \"deceased\"\n  ))\n\niters %>% \n  sample_n(1000) %>% \n  as_tibble() %>% \n  mutate(healthy = 1 / (lambda1 + lambda2),\n         illness = 1 / (lambda3 + lambda4) \n         ) %>% \n  pivot_longer(c(\"healthy\", \"illness\"), names_to = \"state\", values_to = \"value\") %>% \n  group_by(state) %>% \n  ggplot(aes(x = value, y = state)) +\n  geom_point(data = filter(time_in_state, state %in% c(\"illness\", \"healthy\")), aes(x = total_time, y = state), alpha = 0.5, colour = \"blue\") +\n  tidybayes::geom_halfeyeh() +\n  labs(x = \"Days\", title = \"Posterior distribution of the mean time in each state\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: 'tidybayes::geom_halfeyeh' is deprecated.\nUse 'stat_halfeye' instead.\nSee help(\"Deprecated\") and help(\"tidybayes-deprecated\").\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 36 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/mean-time-states-posterior-1.png){width=672}\n:::\n:::\n\n\nMost applications of multi-state survival models have patient attributes associated with each patient. This can be used to inform the next transition and the time to the next transition. I will consider this in a future post.\n\nIn addition, fully observed processes are rare. If the exact time of a state transition is not known or multiple state transitions can happen between observations then the multi-state survival model is partially observed. A continuous time Hidden Markov Model can be used in this case.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}