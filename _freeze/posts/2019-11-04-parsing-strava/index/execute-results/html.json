{
  "hash": "d15a3ad5a4c06bde6d8891b9b4841af8",
  "result": {
    "markdown": "---\ntitle: \"Analysing .fit files in R\"\nauthor: \"Jonny Law\"\ndate: '2019-11-04'\nslug: analysing-fit-files-in-R\ncategories: R\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'tidyr' was built under R version 4.1.2\n```\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'dplyr' was built under R version 4.1.2\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(readr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'readr' was built under R version 4.1.2\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(reticulate)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'reticulate' was built under R version 4.1.2\n```\n:::\n\n```{.r .cell-code}\nlibrary(leaflet)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'leaflet' was built under R version 4.1.2\n```\n:::\n\n```{.r .cell-code}\ntheme_set(theme_minimal())\n```\n:::\n\n\nGarmin running watches output a file type called .fit, the developer SDK can be downloaded from the [ANT website](https://www.thisisant.com/developer/fit-sdk-release-notes). There is also Python library named [fitparse](https://github.com/dtcooper/python-fitparse) which has been written to parse .fit files. This blog post will show you how to use [reticulate](https://rstudio.github.io/reticulate/) to parse a .fit file.\n\nFirst create a Python virtual environment, this is commonly used to store a projects' package collection together to enable more straightforward reproducibility. A virtual environment also contains its own Python and the python package manager pip for installing and managing packages. `reticulate` has a function to create a virtual environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvirtualenv_create(\"r-reticulate\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvirtualenv: r-reticulate\n```\n:::\n\n```{.r .cell-code}\nuse_virtualenv(\"r-reticulate\")\n```\n:::\n\n\n\n## Parsing \n\nThe virtual environment can be used to install the Python package `fitparse`\n\n\n::: {.cell}\n\n```{.r .cell-code}\npy_install(\"fitparse\")\n```\n:::\n\n\nThe library can be imported as an R object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfitparse <- reticulate::import(\"fitparse\")\n```\n:::\n\n\nThen methods and classes defined in the fitparse Python libary can be accessed using the `$` notation. Typing `$` after fitparse (and hitting the `TAB` key) in the RStudio IDE gives a list of top-level methods and classes defined in the fitparse library. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_file <- here::here(\"posts/2019-11-04-parsing-strava/1001800515.fit\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nff <- fitparse$FitFile(fit_file)\n```\n:::\n\n\nWe can use the `get_messages` method on the `FitFile`. This returns a generator, this is a special type of lazy list in Python.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerator <- ff$get_messages(\"record\")\n```\n:::\n\n\n`iterate` is a function provided by the `reticulate` library which can be used to traverse a Python generator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity <- reticulate::iterate(ff$get_messages(\"record\"), function(x) x$get_values())\n```\n:::\n\n\nThis evaluates the generator and applies the function `get_values` to retrieve the details associated with this activity. A list object is returned by R, the first element looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$timestamp\n2017-03-16 17:22:08\n\n$position_lat\n[1] 655852851\n\n$position_long\n[1] -19374352\n\n$distance\n[1] 3.47\n\n$enhanced_altitude\n[1] 88.8\n\n$altitude\n[1] 88.8\n\n$enhanced_speed\n[1] 3.471\n\n$speed\n[1] 3.471\n\n$vertical_oscillation\n[1] 120\n\n$stance_time_percent\n[1] 34.25\n\n$stance_time\n[1] 259\n\n$heart_rate\n[1] 137\n\n$cadence\n[1] 79\n\n$activity_type\n[1] \"running\"\n\n$fractional_cadence\n[1] 0\n```\n:::\n:::\n\n\nWe want to transform this list of lists into a dataframe. The most straightforward way is to extract the elements of interest using the `map` function from [purrr](https://purrr.tidyverse.org/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(activity_tibble <- activity %>%\n  purrr::map_dfr(function(x) tibble(\n    timestamp = readr::parse_datetime(as.character(x$timestamp)),\n    latitude = x$position_lat,\n    longitude = x$position_long,\n    elevation = x$enhanced_altitude,\n    heart_rate = x$heart_rate,\n    cadence = x$cadence\n    )))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 611 × 6\n   timestamp            latitude longitude elevation heart_rate cadence\n   <dttm>                  <int>     <int>     <dbl>      <int>   <int>\n 1 2017-03-16 17:22:08 655852851 -19374352      88.8        137      79\n 2 2017-03-16 17:22:09 655853310 -19375987      90.2        138      79\n 3 2017-03-16 17:22:10 655854123 -19374810      81.2        138      80\n 4 2017-03-16 17:22:15 655856545 -19372657      39.2        139      78\n 5 2017-03-16 17:22:21 655859405 -19368861      54.2        140      79\n 6 2017-03-16 17:22:26 655860948 -19365257      54.6        140      80\n 7 2017-03-16 17:22:32 655860904 -19362723      65.4        138      79\n 8 2017-03-16 17:22:33 655861059 -19361314      69          138      79\n 9 2017-03-16 17:22:37 655860087 -19358357      98.8        135      79\n10 2017-03-16 17:22:44 655860947 -19354267      97          135      80\n# … with 601 more rows\n```\n:::\n:::\n\n\nNotice that the latitude and longitude don't look correct, it turns out they are in semicircles and can be converted to a recognisable coordinate system using the following function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsemicircle_to_degrees <- function(semicircle)\n  semicircle * (180 / 2**31)\n```\n:::\n\n\nApplying the function to the latitude and longitude models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity_tibble <- activity_tibble %>% \n  mutate_at(vars(latitude, longitude), semicircle_to_degrees)\n```\n:::\n\n\nThis is a very basic summary of the activity. We can derive the distance per timestep using the longitude, latitude and timestamp fields.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(activity_tibble <- activity_tibble %>%\n  mutate(\n    time_diff_to_prev = as.numeric(difftime(timestamp, lag(timestamp, default = .$timestamp[1]))),\n    cumtime = cumsum(time_diff_to_prev),\n    dist_to_prev = c(0, sp::spDists(\n      x = as.matrix(.[, c(\"longitude\", \"latitude\")]),\n      longlat = TRUE,\n      segments = TRUE\n    )),\n    elevation_to_prev = elevation - lag(elevation),\n    distance = cumsum(dist_to_prev)\n    )) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 611 × 11\n   timestamp           latitude longitude elevation heart_rate cadence\n   <dttm>                 <dbl>     <dbl>     <dbl>      <int>   <int>\n 1 2017-03-16 17:22:08     55.0     -1.62      88.8        137      79\n 2 2017-03-16 17:22:09     55.0     -1.62      90.2        138      79\n 3 2017-03-16 17:22:10     55.0     -1.62      81.2        138      80\n 4 2017-03-16 17:22:15     55.0     -1.62      39.2        139      78\n 5 2017-03-16 17:22:21     55.0     -1.62      54.2        140      79\n 6 2017-03-16 17:22:26     55.0     -1.62      54.6        140      80\n 7 2017-03-16 17:22:32     55.0     -1.62      65.4        138      79\n 8 2017-03-16 17:22:33     55.0     -1.62      69          138      79\n 9 2017-03-16 17:22:37     55.0     -1.62      98.8        135      79\n10 2017-03-16 17:22:44     55.0     -1.62      97          135      80\n# … with 601 more rows, and 5 more variables: time_diff_to_prev <dbl>,\n#   cumtime <dbl>, dist_to_prev <dbl>, elevation_to_prev <dbl>, distance <dbl>\n```\n:::\n:::\n\n\n## Summarising\n\nWe can calculate a high level summary of the activity similar to what you would find on Garmin connect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity_tibble %>%\n  summarise(\n    total_distance = sum(dist_to_prev),\n    elapsed_time = max(timestamp) - min(timestamp),\n    moving_time = sum(time_diff_to_prev) - sum(\n      ifelse(dist_to_prev == 0, time_diff_to_prev, 0)\n    ),\n    elevation_gain = sum(if_else(elevation_to_prev > 0, elevation_to_prev, 0), na.rm = TRUE),\n    average_heart_rate = round(mean(heart_rate), 0)\n  ) %>%\n  mutate(average_pace = hms::as_hms(as.numeric(moving_time) / total_distance),\n         moving_time = lubridate::seconds_to_period(moving_time)) %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n| total_distance|elapsed_time | moving_time| elevation_gain| average_heart_rate|average_pace   |\n|--------------:|:------------|-----------:|--------------:|------------------:|:--------------|\n|       8.044634|39.65 mins   |     39M 39S|            380|                150|00:04:55.72509 |\n:::\n:::\n\n\nWe can recreate plots commonly found on activity websites such as training peaks, Strava and Garmin Connect, for instance average speed for each 1km:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity_tibble %>% \n  mutate(lap = distance %/% 1) %>% \n  group_by(lap) %>% \n  summarise(lap_distance = sum(dist_to_prev), \n            lap_time = sum(time_diff_to_prev), \n            pace = hms::as_hms(lap_time / lap_distance)) %>% \n  ggplot(aes(x = lap, y = pace)) +\n  geom_col() +\n  xlab(\"Distance (km)\") +\n  ylab(\"Pace (min / km)\") +\n  labs(title = \"Average pace per lap\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity_tibble %>% \n  mutate(distance = cumsum(dist_to_prev)) %>% \n  ggplot(aes(x = distance, y = elevation)) +\n  geom_area(alpha = 0.5) +\n  geom_line(aes(x = distance, y = heart_rate), colour = \"#ff0000\", alpha = 0.5) +\n  xlab(\"Distance (km)\") +\n  ylab(\"Elevation (m)\") +\n  labs(title = \"Elevation and heart rate\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n## Analysing heart rate data\n\nWe can determine how hard the activity was for the athlete using heart rate data. Heart rate is an individual metric and differs between athletes running the same pace. To that end, we must compute the heart rate relative to the maximum heart rate or using [heart rate reserve](https://fellrnr.com/wiki/Heart_Rate_Reserve) (taking into account both the maximum and resting heart rate). Using the max heart rate and resting heart rate, training zones can be determined. These zones are broad and for the convenience of the athlete (and coach) when performing workouts at a given intensity. This intensity should vary depending on the purpose of the workout (recovery, threshold, VO2 max intervals etc.).\n\nSuggested heart rate zones according to [Pete Pfitzinger](https://www.amazon.co.uk/Advanced-Marathoning-Pete-Pfitzinger/dp/149256866X) are: \n\n1. Active recovery: less than 76% MHR\n2. General Aerobic: 70%-81% MHR\n3. Tempo (Marathon pace): 81%-88% MHR\n4. Lactate Threshold: 82%-92% MHR\n5. Anaerobic: 95%+\n\nFor my maximum heart rate of 189, the zones can be written as.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzones <- c(\n  \"one\" = 0.76 * 189,\n  \"two\" = 0.81 * 189,\n  \"three\" = 0.88 * 189,\n  \"four\" = 0.92 * 189,\n  \"five\" = 189)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(tibble::rownames_to_column(data.frame(heart_rate = round(zones, 0)), var = \"zone\"))\n```\n\n::: {.cell-output-display}\n|zone  | heart_rate|\n|:-----|----------:|\n|one   |        144|\n|two   |        153|\n|three |        166|\n|four  |        174|\n|five  |        189|\n:::\n:::\n\n\nThen the time in zones can be plotted for the given activity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_in_zones <- activity_tibble %>%\n  mutate(\n    zone = dplyr::case_when(\n      heart_rate <= zones[1] ~ names(zones[1]),\n      heart_rate <= zones[2] ~ names(zones[2]),\n      heart_rate <= zones[3] ~ names(zones[3]),\n      heart_rate <= zones[4] ~ names(zones[4]),\n      heart_rate <= zones[5] ~ names(zones[5]),\n    )\n  ) %>%\n  mutate(zone = factor(zone, levels = c(\"one\", \"two\", \"three\", \"four\", \"five\"))) %>%\n  group_by(zone) %>%\n  summarise(time_seconds = sum(time_diff_to_prev))\n\ntime_in_zones %>% \n  ggplot(aes(x = zone, y = time_seconds, fill = zone)) +\n  geom_col() +\n  scale_fill_brewer(type = \"seq\",\n                             direction = 1,\n                             palette = \"Reds\") +\n  scale_x_discrete(drop = FALSE) +\n  theme(legend.position = \"none\") +\n  theme_minimal() +\n  coord_flip() +\n  scale_y_time() +\n  geom_label(aes(label = hms::as_hms(time_seconds))) +\n  theme(\n    axis.title.x = element_blank(),\n    legend.position = \"none\",\n    axis.ticks.x = element_blank(),\n    axis.text.x = element_blank()\n  ) +\n  labs(title = \"Time in zones\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n## Training impulse\n\nTRIMP can be used (TRaining IMPulse) to calculate a one-number summary of the activity difficulty, more information on TRIMP can be found [here](https://fellrnr.com/wiki/TRIMP). \n\nThe most straightforward way to calculate TRIMP is calculating the total time in each zone by multiplying the zone number by the total minutes in the corresponding zone.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_in_zones %>% \n  summarise(trimp_zone = sum(as.numeric(zone) * time_seconds / 60)) %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n| trimp_zone|\n|----------:|\n|   87.86667|\n:::\n:::\n\n\nThis number is straightforward to calculate however it lacks nuance. For instance it remains the same if the athlete is at either the upper or lower end of the heart rate range for a given zone. To account for this TRIMP exp can be calculated:\n\n\n$$\\textrm{TRIMP}^{\\textrm{exp}} = \\sum_{i=1}^T \\textrm{D}_i \\cdot \\textrm{HRr} \\cdot 0.64e^y$$\n\nWhere, $\\textrm{D}_i$ is the duration of a single measurement (typically one to five seconds on a Garmin watch), HRr is the heart rate reserve (maximum heart rate - resting heart rate), $y$ is the percentage of heart rate reserve multiplied by 1.92 for men and 1.67 for women. \n\n::: {.cell}\n\n```{.r .cell-code}\ntrimp_exp <- function(heartrate, time_seconds, max_hr, resting_hr, sex = \"Male\") {\n  heart_rate_reserve <- max_hr - resting_hr\n  hrr <- heartrate / heart_rate_reserve\n  constant <- if_else(sex == \"Male\", 1.92, 1.67)\n  sum((time_seconds / 60) * hrr * 0.64 * exp(constant * hrr))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nactivity_tibble %>% \n  summarise(trimp_exp = trimp_exp(heart_rate, time_diff_to_prev, 189, 42)) %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n| trimp_exp|\n|---------:|\n|  187.6727|\n:::\n:::\n\nThese summaries can be used to calculate the overall training workload for an athlete to assist with planning and reviewing training plans. This is typically used in addition to training time and distance covered.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}